---
/**
 * Sidebar Component - Left navigation panel
 * Mintlify-style with collapsible sections and icons
 * Supports both auto-tree mode (from documents) and manual mode (from admin config)
 */

import type { Document, SideMenuConfig, SideMenuItem } from '../lib/cms';
import {
  locales as i18nLocales,
  localeNames,
  isValidLocale,
  defaultLocale as i18nDefaultLocale,
  type Locale
} from '../lib/i18n';
import Icon from './Icon';
import { iconMap, type IconName } from '../lib/icons';
import {
  isIndexFile as isDocIndexFile,
  extractSlugFromPath as extractDocSlug,
} from '../lib/doc-helpers';

interface Props {
  documents: Document[];
  currentPath: string;
  logoUrl?: string;
  logoDarkUrl?: string;
  logoIconUrl?: string;
  logoIconDarkUrl?: string;
  logoWidth?: number;
  logoHeight?: number;
  siteName?: string;
  supportedLocales?: string[];
  defaultLocale?: string;
  sideMenu?: SideMenuConfig;
  /** Current locale for the page */
  locale?: Locale;
  /** Available translations for the current document */
  availableTranslations?: Locale[];
  /** Mapping of locale to translated slug for URL building */
  translationSlugs?: Partial<Record<Locale, string>>;
}

const {
  documents,
  currentPath,
  logoUrl,
  logoDarkUrl,
  logoIconUrl,
  logoIconDarkUrl,
  logoWidth = 120,
  logoHeight = 32,
  siteName = 'Docs',
  supportedLocales = [],
  defaultLocale = 'en',
  sideMenu,
  locale: propLocale,
  availableTranslations = [],
  translationSlugs = {},
} = Astro.props;

// Determine current locale from prop, URL, or default
const urlLocale = Astro.url.pathname.split('/').filter(Boolean)[0];
const currentLocale: Locale = propLocale || (isValidLocale(urlLocale) ? urlLocale : i18nDefaultLocale);

// Determine navigation mode
const isManualMode = sideMenu?.mode === 'manual' && sideMenu.items && sideMenu.items.length > 0;

// Extract products and tabs from sideMenu (for folder-based navigation)
interface FolderNavItem {
  id: string;
  label: string;
  icon?: string;
  folder?: string;
  collection?: string;
  defaultActive?: boolean;
}

const products: FolderNavItem[] = [];
const tabs: FolderNavItem[] = [];
const nonProductItems: SideMenuItem[] = [];

if (isManualMode && sideMenu?.items) {
  for (const item of sideMenu.items) {
    if (item.type === 'product' && !item.hidden) {
      products.push({
        id: item.id,
        label: item.label,
        icon: item.icon,
        folder: item.folder,
        collection: item.collection || 'docs',
        defaultActive: item.defaultActive,
      });
    } else if (item.type === 'tab' && !item.hidden) {
      tabs.push({
        id: item.id,
        label: item.label,
        icon: item.icon,
        folder: item.folder,
        collection: item.collection || 'docs',
        defaultActive: item.defaultActive,
      });
    } else if (item.type !== 'tab' && !item.hidden) {
      // Exclude tabs from regular items - they're rendered in header
      nonProductItems.push(item);
    }
  }
}

// Determine which product is active based on current path or default
// URL structure: /{locale}/{folder}/... (no /docs prefix since subdomain indicates docs)
const activeProduct = products.find(p => {
  if (!p.folder) return false;

  const folder = p.folder.replace(/^\/|\/$/g, '');

  // Normalize current path and remove leading/trailing slashes
  const normPath = currentPath.replace(/^\/|\/$/g, '');
  const parts = normPath.split('/');

  // Path format: {locale}/{folder}/...
  // So parts[0] = locale (en, es, etc.), parts[1] = folder (device-management, platform, etc.)
  if (parts.length >= 2) {
    const pathFolder = parts[1]; // The folder after locale
    if (pathFolder === folder) return true;
  }

  // Also check without locale for backwards compatibility
  if (normPath === folder || normPath.startsWith(folder + '/')) return true;

  return false;
}) || products.find(p => p.defaultActive) || products[0];

const hasProducts = products.length > 0;

// Determine which tab is active by default
const defaultActiveTab = tabs.find(t => t.defaultActive) || tabs[0];
const hasTabs = tabs.length > 0;
const tabsJson = JSON.stringify(tabs);

// Group documents by section/category
interface NavGroup {
  title: string;
  icon?: string;
  href?: string;
  active?: boolean;
  items: NavItem[];
  subgroups?: NavGroup[];
}

interface NavItem {
  label: string;
  href: string;
  icon?: string;
  active: boolean;
  method?: string; // HTTP method for API endpoints (GET, POST, etc.)
}

/**
 * Extract a clean slug from the document path
 * Matches the logic in [...slug].astro
 * Removes: file extension, content/ prefix, locale prefix (en/, es/, etc.), docs/ prefix
 */
function extractSlugFromPath(path: string): string {
  let slug = path.replace(/\.mdx?$/, '');           // Remove file extension
  slug = slug.replace(/^src\/content\//, '');        // Remove src/content/ prefix
  slug = slug.replace(/^content\//, '');             // Remove content/ prefix
  slug = slug.replace(/^[a-z]{2}\//, '');            // Remove locale prefix (en/, es/, etc.)
  slug = slug.replace(/^docs\//, '');                // Remove docs/ prefix (subdomain handles this)
  slug = slug.replace(/^\/+/, '');                   // Remove leading slashes
  return slug;
}

/**
 * Format a path segment into a readable title
 */
function formatTitle(segment: string): string {
  return segment
    .replace(/-/g, ' ')
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

/**
 * Build hierarchical navigation from document paths
 * Groups by folder structure for a proper sidebar tree
 */
function buildNavigation(docs: Document[]): NavGroup[] {
  // Sort by sidebar_position, order, or path
  const sortedDocs = [...docs].sort((a, b) => {
    const posA = a.sidebar_position ?? a.order_num ?? a.weight ?? 999;
    const posB = b.sidebar_position ?? b.order_num ?? b.weight ?? 999;
    if (posA !== posB) return posA - posB;
    return (a.path || '').localeCompare(b.path || '');
  });

  // Build a tree structure from paths
  interface TreeNode {
    title: string;
    items: NavItem[];
    children: Record<string, TreeNode>;
    icon?: string;
    href?: string;
    active?: boolean;
    order?: number;
  }

  const root: Record<string, TreeNode> = {};

  // First pass: collect index/archive docs so we can link folder headings
  const indexDocsByFolder = new Map<string, Document>();
  for (const doc of sortedDocs) {
    if (doc.visible === false || doc.visible === 0) continue;
    if (!doc.path) continue;
    if (isDocIndexFile(doc) || doc.type === 'archive') {
      // Get the folder key: e.g. "device-management/ipados" from the slug
      const slug = extractDocSlug(doc.path, true);
      indexDocsByFolder.set(slug, doc);
    }
  }

  for (const doc of sortedDocs) {
    if (doc.visible === false || doc.visible === 0) continue;

    // Skip index/archive files - they are folder pages, not menu items
    if (isDocIndexFile(doc)) continue;
    if (doc.type === 'archive') continue;

    // Build href with locale prefix using shared slug logic (handles folder-named files)
    let href: string;
    if (doc.path) {
      const pathSlug = extractDocSlug(doc.path, false).toLowerCase();
      href = `/${currentLocale}/${pathSlug}`;
    } else if (doc.slug) {
      const cleanSlug = doc.slug.replace(/^docs\//, '');
      href = `/${currentLocale}/${cleanSlug.toLowerCase()}`;
    } else {
      href = `/${currentLocale}/${doc.id}`;
    }

    // Extract HTTP method from headline (e.g. "GET /v1/devices" → "GET")
    const headlineMethod = doc.headline?.match(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+/i)?.[1]?.toUpperCase();

    const navItem: NavItem = {
      label: (doc.item_name && doc.item_name !== 'null') ? doc.item_name : doc.title,
      href,
      icon: doc.sidebar_icon || doc.icon,
      active: currentPath === href || currentPath.startsWith(href + '/'),
      method: headlineMethod,
    };

    // Extract path parts (skip collection, get folder structure)
    // e.g., docs/platform/workspaces/Overview.md -> [platform, workspaces]
    const slug = doc.path ? extractDocSlug(doc.path, false) : (doc.slug?.replace(/^docs\//, '') || doc.id);
    const pathParts = slug.split('/');

    // First part is the top-level group (e.g., 'device-management' or 'platform')
    const groupKey = pathParts[0];
    // Remaining parts (excluding the filename) are subfolders
    const folders = pathParts.slice(1, -1);

    if (pathParts.length === 1) {
      // Root level document - put in its own group or General
      const rootKey = doc.collection || 'General';
      if (!root[rootKey]) {
        root[rootKey] = { title: formatTitle(rootKey), items: [], children: {} };
      }
      root[rootKey].items.push(navItem);
    } else {
      // Navigate/create the tree structure starting from the top-level group
      if (!root[groupKey]) {
        root[groupKey] = { title: formatTitle(groupKey), items: [], children: {} };
      }

      if (folders.length === 0) {
        // Only group and filename: e.g., device-management/overview.md
        root[groupKey].items.push(navItem);
      } else {
        // Deep nesting: e.g., device-management/ipados/overview.md
        let current = root[groupKey].children;
        for (let i = 0; i < folders.length; i++) {
          const folder = folders[i];
          const key = folder;

          if (!current[key]) {
            current[key] = {
              title: formatTitle(folder),
              items: [],
              children: {}
            };
          }

          if (i === folders.length - 1) {
            // This is the deepest folder, add item here
            current[key].items.push(navItem);
          }
          current = current[key].children;
        }
      }
    }
  }

  // Second pass: create tree nodes for index docs whose folders have no children yet
  // (e.g. android/android.md with no child pages → still shows as a nav item)
  for (const [folderSlug, indexDoc] of indexDocsByFolder) {
    const parts = folderSlug.split('/');
    // parts[0] is the top-level group key (e.g. "device-management")
    // parts[1+] are subfolders (e.g. "android")
    if (parts.length < 2) continue; // skip top-level index files

    const groupKey = parts[0];
    if (!root[groupKey]) {
      root[groupKey] = { title: formatTitle(groupKey), items: [], children: {} };
    }

    // Navigate to the parent and check if the subfolder node exists
    let target = root[groupKey].children;
    for (let i = 1; i < parts.length - 1; i++) {
      if (!target[parts[i]]) {
        target[parts[i]] = { title: formatTitle(parts[i]), items: [], children: {} };
      }
      target = target[parts[i]].children;
    }

    const leafKey = parts[parts.length - 1];
    if (!target[leafKey]) {
      // Folder doesn't exist in tree (no children) — create it
      const href = `/${currentLocale}/${folderSlug.toLowerCase()}`;
      target[leafKey] = {
        title: (indexDoc.item_name && indexDoc.item_name !== 'null') ? indexDoc.item_name : indexDoc.title,
        items: [],
        children: {},
        icon: indexDoc.sidebar_icon || indexDoc.icon,
        href,
        active: currentPath === href || currentPath.startsWith(href + '/'),
      };
    }
  }

  // Apply index doc info (href, active, title) to matching tree nodes
  function applyIndexDocs(tree: Record<string, TreeNode>, parentSlug: string) {
    for (const [key, node] of Object.entries(tree)) {
      const folderSlug = parentSlug ? `${parentSlug}/${key}` : key;
      const indexDoc = indexDocsByFolder.get(folderSlug);
      if (indexDoc) {
        const href = `/${currentLocale}/${folderSlug.toLowerCase()}`;
        if (!node.href) node.href = href;
        node.active = currentPath === href || currentPath.startsWith(href + '/');
        if (indexDoc.item_name && indexDoc.item_name !== 'null') node.title = indexDoc.item_name;
        else if (indexDoc.title) node.title = indexDoc.title;
        if (indexDoc.sidebar_icon || indexDoc.icon) node.icon = indexDoc.sidebar_icon || indexDoc.icon;
        if (indexDoc.sidebar_position != null) node.order = indexDoc.sidebar_position;
      }
      if (Object.keys(node.children).length > 0) {
        applyIndexDocs(node.children, folderSlug);
      }
    }
  }
  applyIndexDocs(root, '');

  // Convert tree to NavGroup array with proper nesting, sorted by order
  function treeToGroups(tree: Record<string, TreeNode>): NavGroup[] {
    return Object.values(tree)
      .sort((a, b) => {
        const orderA = a.order ?? 999;
        const orderB = b.order ?? 999;
        if (orderA !== orderB) return orderA - orderB;
        return a.title.localeCompare(b.title);
      })
      .map(node => ({
        title: node.title,
        icon: node.icon,
        href: node.href,
        active: node.active,
        items: node.items,
        subgroups: Object.keys(node.children).length > 0 ? treeToGroups(node.children) : undefined,
      }));
  }

  return treeToGroups(root);
}

/**
 * Check if a path is active compared to current path
 * Handles trailing slashes and nested paths
 */
function isPathActive(path: string, currentPath: string): boolean {
  const normPath = decodeURIComponent(path).replace(/\/+$/, '') || '/';
  const normCurrent = decodeURIComponent(currentPath).replace(/\/+$/, '') || '/';
  return normCurrent === normPath || normCurrent.startsWith(normPath + '/');
}

/**
 * Check if a group or any of its children are active
 */
function isGroupActive(group: NavGroup, currentPath: string): boolean {
  if (group.href && isPathActive(group.href, currentPath)) return true;
  if (group.active) return true;
  if (group.items.some(item => isPathActive(item.href, currentPath) || item.active)) return true;
  if (group.subgroups && group.subgroups.some(sub => isGroupActive(sub, currentPath))) return true;
  return false;
}

/**
 * Convert SideMenuItem from admin config to NavGroup format
 * Handles all item types: anchor, tab, dropdown, group, language, product, version, page
 */
function convertSideMenuToNavGroups(items: SideMenuItem[]): NavGroup[] {
  const groups: NavGroup[] = [];

  function processChildren(children: SideMenuItem[]): { navItems: NavItem[], subgroups: NavGroup[] } {
    const navItems: NavItem[] = [];
    const subgroups: NavGroup[] = [];

    for (const child of children) {
      if (child.hidden) continue;

      // Check if this child has nested children (becomes a subgroup)
      if (['group', 'dropdown', 'tab'].includes(child.type) && child.children && child.children.length > 0) {
        const nested = processChildren(child.children);
        subgroups.push({
          title: child.label,
          icon: child.icon,
          items: nested.navItems,
          subgroups: nested.subgroups.length > 0 ? nested.subgroups : undefined,
        });
      } else {
        // Regular nav item (page, anchor, or childless group)
        const isExternal = child.href?.startsWith('http');
        navItems.push({
          label: child.label,
          href: child.href || '#',
          icon: child.icon,
          active: !isExternal && (currentPath === child.href || currentPath.startsWith((child.href || '') + '/')),
        });
      }
    }

    return { navItems, subgroups };
  }

  for (const item of items) {
    if (item.hidden) continue;

    // Items that can have children become groups
    if (['tab', 'dropdown', 'group'].includes(item.type)) {
      if (item.children && item.children.length > 0) {
        const { navItems, subgroups } = processChildren(item.children);
        groups.push({
          title: item.label,
          icon: item.icon,
          items: navItems,
          subgroups: subgroups.length > 0 ? subgroups : undefined,
        });
      } else {
        // Empty group - still create it as a header
        groups.push({
          title: item.label,
          icon: item.icon,
          items: [],
        });
      }
    } else if (item.type === 'anchor' || item.type === 'page') {
      // Single items - add to a standalone group with same name
      const isExternal = item.href?.startsWith('http');
      groups.push({
        title: item.label,
        icon: item.icon,
        items: [{
          label: item.label,
          href: item.href || '#',
          icon: item.icon,
          active: !isExternal && (currentPath === item.href || currentPath.startsWith((item.href || '') + '/')),
        }],
      });
    } else if (item.type === 'language' || item.type === 'product' || item.type === 'version') {
      // Special selector types - render as groups
      groups.push({
        title: item.label,
        icon: item.icon,
        items: [],
      });
    }
  }

  return groups;
}

// Build navigation based on mode
// If we have products, the navigation will be loaded dynamically based on active product
// Otherwise, use the standard navigation building
const navigation = isManualMode
  ? (hasProducts ? convertSideMenuToNavGroups(nonProductItems) : convertSideMenuToNavGroups(sideMenu!.items))
  : buildNavigation(documents);

// Serialize products for client-side use
const productsJson = JSON.stringify(products);

// Aliases for icon names that DON'T follow the standard kebab→camelCase pattern.
// All other names (e.g. 'folder-open' → 'folderOpen') are auto-converted at runtime.
const iconAliases: Record<string, string> = {
  'settings-2': 'settings',
  cog: 'settings',
  'columns-3-cog': 'settings',
  'trash-2': 'trash',
  'monitor-smartphone': 'smartphone',
  'tablet-smartphone': 'tablet',
  iphone: 'smartphone',
  ipad: 'tablet',
  'bar-chart-2': 'barChart',
};

// Convert kebab-case to camelCase: 'folder-open' → 'folderOpen'
function kebabToCamel(str: string): string {
  return str.replace(/-([a-z0-9])/g, (_, c: string) => c.toUpperCase());
}

function getIconName(iconName?: string): IconName {
  if (!iconName) return 'document';
  const lower = iconName.toLowerCase();
  // 1. Check aliases (non-trivial mappings like cog → settings)
  if (iconAliases[lower]) return iconAliases[lower] as IconName;
  // 2. Auto-convert kebab→camelCase and check if it's a valid icon
  const camel = kebabToCamel(lower);
  if (camel in iconMap) return camel as IconName;
  // 3. Check raw lowercase in iconMap (single-word keys like 'apple', 'android')
  if (lower in iconMap) return lower as IconName;
  // 4. Fallback
  return 'document';
}

function isFolderIcon(iconName?: string): boolean {
  if (!iconName) return true; // default icon is folder
  const lower = iconName.toLowerCase();
  return lower === 'folder' || lower === 'folder-open' || lower === 'folder-tree' || lower === 'folder-plus';
}

// Build languages array from supportedLocales (fallback to i18n locales)
const languages = supportedLocales.length > 0
  ? supportedLocales.map(code => ({ code: code.toUpperCase() }))
  : i18nLocales.map(code => ({ code: code.toUpperCase() }));

// Get current language display
const currentLang = languages.find(l => l.code.toLowerCase() === currentLocale) || languages[0];

// Determine which translations are available for the smart language selector
const effectiveTranslations: Locale[] = availableTranslations.length > 0
  ? availableTranslations
  : [currentLocale]; // If not provided, only show current locale

// CMS URL for client-side navigation API calls
const cmsUrl = import.meta.env.PUBLIC_CMS_URL || import.meta.env.CMS_URL || '';

// Collect only the icons actually used by CMS data at build time
const usedIcons = new Set<string>([
  // Structural icons always needed by the sidebar
  'folder', 'folderOpen', 'document', 'chevronDown',
]);

// Walk sideMenu items recursively to collect icons
function collectMenuIcons(items: SideMenuItem[]) {
  for (const item of items) {
    if (item.icon) usedIcons.add(getIconName(item.icon));
    if (item.children) collectMenuIcons(item.children);
  }
}
if (sideMenu?.items) collectMenuIcons(sideMenu.items);

// Collect icons from products
for (const p of products) {
  if (p.icon) usedIcons.add(getIconName(p.icon));
}

// Collect icons from navigation groups
function collectNavIcons(groups: NavGroup[]) {
  for (const g of groups) {
    if (g.icon) usedIcons.add(getIconName(g.icon));
    for (const item of g.items) {
      if (item.icon) usedIcons.add(getIconName(item.icon));
    }
    if (g.subgroups) collectNavIcons(g.subgroups);
  }
}
collectNavIcons(navigation);

// Build filtered iconMap with only the used icons
const usedIconMap = Object.fromEntries(
  Object.entries(iconMap).filter(([k]) => usedIcons.has(k))
);
---

<aside
  class="sidebar"
  data-cms-url={cmsUrl}
  data-icon-name-map={JSON.stringify(iconAliases)}
  data-icon-map={JSON.stringify(usedIconMap)}
>
  <!-- Logo / Site Name -->
  <div class="sidebar-header">
    <a href="/" class="flex items-center gap-3">
      {logoUrl ? (
        <div class="sidebar-logo">
          {/* Light mode logo */}
          <img
            src={logoUrl}
            alt={siteName}
            class={`logo-light ${logoDarkUrl ? 'dark:hidden' : ''}`}
            style={`max-width: ${logoWidth}px; max-height: ${logoHeight}px; height: auto; width: auto;`}
          />
          {/* Dark mode logo (if provided) */}
          {logoDarkUrl && (
            <img
              src={logoDarkUrl}
              alt={siteName}
              class="logo-dark hidden dark:block"
              style={`max-width: ${logoWidth}px; max-height: ${logoHeight}px; height: auto; width: auto;`}
            />
          )}
        </div>
      ) : (logoIconUrl || logoIconDarkUrl) ? (
        <div class="sidebar-logo">
          {/* Light mode logo icon */}
          <img
            src={logoIconUrl || logoIconDarkUrl}
            alt={siteName}
            class={`logo-light ${logoIconDarkUrl ? 'dark:hidden' : ''}`}
            style={`max-width: 32px; max-height: 32px; height: auto; width: auto;`}
          />
          {/* Dark mode logo icon (if provided) */}
          {logoIconDarkUrl && (
            <img
              src={logoIconDarkUrl}
              alt={siteName}
              class="logo-dark hidden dark:block"
              style={`max-width: 32px; max-height: 32px; height: auto; width: auto;`}
            />
          )}
          <span class="font-semibold text-[var(--color-text-primary)]">{siteName}</span>
        </div>
      ) : (
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-lg bg-[var(--color-primary)] flex items-center justify-center">
            <Icon name="document" className="w-5 h-5 text-white" aria-hidden={true} client:only="react" />
          </div>
          <span class="font-semibold text-[var(--color-text-primary)]">{siteName}</span>
        </div>
      )}
    </a>
  </div>

  <!-- Products Selector (if products exist) -->
  {hasProducts && (
    <div class="product-selector" data-products={productsJson}>
      {products.map((product, index) => (
        <button
          type="button"
          class:list={[
            'product-btn',
            { 'active': product.id === activeProduct.id }
          ]}
          data-product-id={product.id}
          data-product-folder={product.folder}
          data-product-collection={product.collection}
        >
          {product.icon && (
            <Icon name={getIconName(product.icon)} className="product-icon" aria-hidden={true} client:only="react" />
          )}
          <span class="product-label">{product.label}</span>
        </button>
      ))}
    </div>
  )}

  <!-- Product Navigation (lazy-loaded content area) -->
  {hasProducts && (
    <div class="product-nav-container" id="product-nav-container">
      <div class="product-nav-skeleton">
        <!-- Skeleton folder with children -->
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
            <div class="skeleton-bar skeleton-item"></div>
          </div>
        </div>
        <!-- Second skeleton folder -->
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title short"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
          </div>
        </div>
        <!-- Third skeleton folder -->
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title"></div>
        </div>
      </div>
      <!-- Content will be loaded dynamically -->
    </div>
  )}

  <!-- Tab Navigation (lazy-loaded content area, controlled by header tabs) -->
  {hasTabs && (
    <div class="tab-nav-container" id="tab-nav-container" data-tabs={tabsJson}>
      <div class="tab-nav-skeleton">
        <!-- Skeleton folder with children -->
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
            <div class="skeleton-bar skeleton-item"></div>
          </div>
        </div>
        <!-- Second skeleton folder -->
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title short"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
          </div>
        </div>
      </div>
      <!-- Content will be loaded dynamically based on active tab -->
    </div>
  )}

  <!-- Static Navigation (for non-product/tab items or when no products/tabs) -->
  <nav class:list={['sidebar-content', 'scrollbar-on-hover', { 'has-products': hasProducts, 'has-tabs': hasTabs }]}>
    {navigation.length > 0 ? (
      navigation.map((group) => {
        const isExpanded = isGroupActive(group, currentPath);

        return (
          <div class="sidebar-nav-group" data-nav-group>
            <div
              class:list={['sidebar-nav-group-title', { active: group.href && (isPathActive(group.href, currentPath) || group.active) }]}
              data-nav-toggle
              aria-expanded={isExpanded ? 'true' : 'false'}
            >
              {group.href ? (
                <a href={group.href} class="nav-toggle-link sidebar-nav-group-link">
                  <span class="group-title-content">
                    <Icon name={getIconName(group.icon || 'folder')} className="group-title-icon" aria-hidden={true} client:only="react" />
                    <span class="truncate">{group.title}</span>
                  </span>
                </a>
              ) : (
                <span class="nav-toggle-link">
                  <span class="group-title-content">
                    <Icon name={getIconName(group.icon || 'folder')} className="group-title-icon" aria-hidden={true} client:only="react" />
                    <span class="truncate">{group.title}</span>
                  </span>
                </span>
              )}
              <button type="button" class="nav-chevron-btn" data-nav-chevron aria-label="Toggle expand">
                <Icon
                  name="chevronDown"
                  className="nav-chevron"
                  style={isExpanded ? { transform: 'rotate(180deg)' } : undefined}
                  aria-hidden={true}
                  client:only="react"
                />
              </button>
            </div>
            <div
              class="nav-group-content"
              data-nav-content
              style={isExpanded ? '' : 'display: none;'}
            >
              {/* Direct items in this group */}
              {group.items.length > 0 && (
                <ul>
                  {group.items.map((item) => (
                    <li>
                      <a
                        href={item.href}
                        class:list={['sidebar-nav-item', { active: isPathActive(item.href, currentPath) || item.active }]}
                      >
                        {item.method && (
                          <span class={`sidebar-method-badge method-${item.method.toLowerCase()}`}>{item.method}</span>
                        )}
                        {!item.method && (
                          <Icon name={getIconName(item.icon || 'document')} className="nav-item-icon" aria-hidden={true} client:only="react" />
                        )}
                        <span class="nav-item-label">{item.label}</span>
                      </a>
                    </li>
                  ))}
                </ul>
              )}

              {/* Nested subgroups */}
              {group.subgroups && group.subgroups.map((subgroup) => {
                const subHasActive = isGroupActive(subgroup, currentPath);
                const hasChildren = subgroup.items.length > 0 || (subgroup.subgroups && subgroup.subgroups.length > 0);
                const subIsFolderIcon = isFolderIcon(subgroup.icon);
                return hasChildren ? (
                  <div class="sidebar-nav-subgroup" data-nav-group>
                    <div
                      class:list={['sidebar-nav-subgroup-title', { active: subgroup.href && (isPathActive(subgroup.href, currentPath) || subgroup.active) }]}
                      data-nav-toggle
                      {...(subIsFolderIcon ? { 'data-subfolder-toggle': '' } : {})}
                      aria-expanded={subHasActive ? 'true' : 'false'}
                    >
                      {subgroup.href ? (
                        <a href={subgroup.href} class="nav-toggle-link sidebar-nav-subgroup-link">
                          <span class="group-title-content">
                            {subIsFolderIcon ? (
                              <>
                                <Icon name={getIconName(subgroup.icon || 'folder')} className="group-title-icon subfolder-icon-closed" aria-hidden={true} client:only="react" />
                                <Icon name="folderOpen" className="group-title-icon subfolder-icon-open" aria-hidden={true} client:only="react" />
                              </>
                            ) : (
                              <Icon name={getIconName(subgroup.icon)} className="group-title-icon" aria-hidden={true} client:only="react" />
                            )}
                            <span class="truncate">{subgroup.title}</span>
                          </span>
                        </a>
                      ) : (
                        <span class={subIsFolderIcon ? "nav-toggle-link" : "nav-toggle-link"} {...(subIsFolderIcon ? { 'data-subfolder-link': '', role: 'button', tabindex: '0' } : {})} >
                          <span class="group-title-content">
                            {subIsFolderIcon ? (
                              <>
                                <Icon name={getIconName(subgroup.icon || 'folder')} className="group-title-icon subfolder-icon-closed" aria-hidden={true} client:only="react" />
                                <Icon name="folderOpen" className="group-title-icon subfolder-icon-open" aria-hidden={true} client:only="react" />
                              </>
                            ) : (
                              <Icon name={getIconName(subgroup.icon)} className="group-title-icon" aria-hidden={true} client:only="react" />
                            )}
                            <span class="truncate">{subgroup.title}</span>
                          </span>
                        </span>
                      )}
                      {!subIsFolderIcon && (
                        <button type="button" class="nav-chevron-btn" data-nav-chevron aria-label="Toggle expand">
                          <Icon
                            name="chevronDown"
                            className="nav-chevron-sub"
                            style={subHasActive ? { transform: 'rotate(180deg)' } : undefined}
                            aria-hidden={true}
                            client:only="react"
                          />
                        </button>
                      )}
                    </div>
                    <ul
                      class="nav-subgroup-content"
                      data-nav-content
                      style={subHasActive ? '' : 'display: none;'}
                    >
                      {/* Render nested sub-folders first */}
                      {subgroup.subgroups && subgroup.subgroups.map((nested) => {
                        const nestedHasActive = isGroupActive(nested, currentPath);
                        const nestedHasChildren = nested.items.length > 0 || (nested.subgroups && nested.subgroups.length > 0);
                        const nestedIsFolderIcon = isFolderIcon(nested.icon);
                        return nestedHasChildren ? (
                          <li>
                            <div class="sidebar-nav-subgroup" data-nav-group>
                              <div
                                class:list={['sidebar-nav-subgroup-title', { active: nested.href && (isPathActive(nested.href, currentPath) || nested.active) }]}
                                data-nav-toggle
                                {...(nestedIsFolderIcon ? { 'data-subfolder-toggle': '' } : {})}
                                aria-expanded={nestedHasActive ? 'true' : 'false'}
                              >
                                {nested.href ? (
                                  <a href={nested.href} class="nav-toggle-link sidebar-nav-subgroup-link">
                                    <span class="group-title-content">
                                      {nestedIsFolderIcon ? (
                                        <>
                                          <Icon name={getIconName(nested.icon || 'folder')} className="group-title-icon subfolder-icon-closed" aria-hidden={true} client:only="react" />
                                          <Icon name="folderOpen" className="group-title-icon subfolder-icon-open" aria-hidden={true} client:only="react" />
                                        </>
                                      ) : (
                                        <Icon name={getIconName(nested.icon)} className="group-title-icon" aria-hidden={true} client:only="react" />
                                      )}
                                      <span class="truncate">{nested.title}</span>
                                    </span>
                                  </a>
                                ) : (
                                  <span class={nestedIsFolderIcon ? "nav-toggle-link" : "nav-toggle-link"} {...(nestedIsFolderIcon ? { 'data-subfolder-link': '', role: 'button', tabindex: '0' } : {})}>
                                    <span class="group-title-content">
                                      {nestedIsFolderIcon ? (
                                        <>
                                          <Icon name={getIconName(nested.icon || 'folder')} className="group-title-icon subfolder-icon-closed" aria-hidden={true} client:only="react" />
                                          <Icon name="folderOpen" className="group-title-icon subfolder-icon-open" aria-hidden={true} client:only="react" />
                                        </>
                                      ) : (
                                        <Icon name={getIconName(nested.icon)} className="group-title-icon" aria-hidden={true} client:only="react" />
                                      )}
                                      <span class="truncate">{nested.title}</span>
                                    </span>
                                  </span>
                                )}
                                {!nestedIsFolderIcon && (
                                  <button type="button" class="nav-chevron-btn" data-nav-chevron aria-label="Toggle expand">
                                    <Icon
                                      name="chevronDown"
                                      className="nav-chevron-sub"
                                      style={nestedHasActive ? { transform: 'rotate(180deg)' } : undefined}
                                      aria-hidden={true}
                                      client:only="react"
                                    />
                                  </button>
                                )}
                              </div>
                              <ul
                                class="nav-subgroup-content"
                                data-nav-content
                                style={nestedHasActive ? '' : 'display: none;'}
                              >
                                {nested.items.map((nItem) => (
                                  <li>
                                    <a
                                      href={nItem.href}
                                      class:list={['sidebar-nav-item sidebar-nav-item-nested', { active: isPathActive(nItem.href, currentPath) || nItem.active }]}
                                    >
                                      {nItem.method && (
                                        <span class={`sidebar-method-badge method-${nItem.method.toLowerCase()}`}>{nItem.method}</span>
                                      )}
                                      {!nItem.method && (
                                        <Icon name={getIconName(nItem.icon || 'document')} className="nav-item-icon" aria-hidden={true} client:only="react" />
                                      )}
                                      <span class="nav-item-label">{nItem.label}</span>
                                    </a>
                                  </li>
                                ))}
                              </ul>
                            </div>
                          </li>
                        ) : nested.href ? (
                          <li>
                            <a
                              href={nested.href}
                              class:list={['sidebar-nav-item', { active: isPathActive(nested.href, currentPath) || nested.active }]}
                            >
                              <Icon name={getIconName(nested.icon || 'document')} className="nav-item-icon" aria-hidden={true} client:only="react" />
                              <span class="nav-item-label">{nested.title}</span>
                            </a>
                          </li>
                        ) : null;
                      })}
                      {/* Render leaf items */}
                      {subgroup.items.map((item) => (
                        <li>
                          <a
                            href={item.href}
                            class:list={['sidebar-nav-item sidebar-nav-item-nested', { active: isPathActive(item.href, currentPath) || item.active }]}
                          >
                            {item.method && (
                              <span class={`sidebar-method-badge method-${item.method.toLowerCase()}`}>{item.method}</span>
                            )}
                            {!item.method && (
                              <Icon name={getIconName(item.icon || 'document')} className="nav-item-icon" aria-hidden={true} client:only="react" />
                            )}
                            <span class="nav-item-label">{item.label}</span>
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                ) : subgroup.href ? (
                  /* Leaf subgroup — no children, just a clickable link */
                  <li>
                    <a
                      href={subgroup.href}
                      class:list={['sidebar-nav-item', { active: isPathActive(subgroup.href, currentPath) || subgroup.active }]}
                    >
                      <Icon name={getIconName(subgroup.icon || 'document')} className="nav-item-icon" aria-hidden={true} client:only="react" />
                      <span class="nav-item-label">{subgroup.title}</span>
                    </a>
                  </li>
                ) : null;
              })}
            </div>
          </div>
        );
      })
    ) : (
      <div class="px-4 py-4 text-sm text-[var(--color-text-muted)]">
        No documents found
      </div>
    )}
  </nav>

  <!-- Footer with language selector and theme toggle (fixed at bottom) -->
  <div class="sidebar-footer">
    <!-- Language Selector (same style as home header) -->
    <div class="sidebar-lang-selector" data-language-selector>
      <button
        class="sidebar-lang-btn"
        data-language-toggle
        aria-expanded="false"
        aria-haspopup="listbox"
        aria-label="Select language"
      >
        <svg class="sidebar-lang-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/><path d="M6 4.71c.78.711 2.388 2.653 2.575 4.737C8.75 11.396 10.035 12.98 12 13c.755.008 1.518-.537 1.516-1.292c0-.233-.039-.472-.099-.692A1.4 1.4 0 0 1 13.5 10c.61-1.257 1.81-1.595 2.76-2.278c.421-.303.806-.623.975-.88c.469-.71.937-2.131.703-2.842M22 13c-.33.931-.562 3.375-4.282 3.414c0 0-3.293 0-4.281 1.862c-.791 1.49-.33 3.103 0 3.724"/>
        </svg>
        <span class="sidebar-lang-code">{currentLocale.toUpperCase()}</span>
        <svg class="sidebar-lang-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="6 15 12 9 18 15"/>
        </svg>
      </button>
      <div
        class="sidebar-lang-dropdown"
        data-language-dropdown
        data-position="top"
        role="listbox"
        aria-label="Available languages"
      >
        {effectiveTranslations.map(locale => (
          <a
            href={`/${locale}/${currentPath.split('/').filter(Boolean).slice(1).join('/')}`}
            class:list={['sidebar-lang-option', { active: locale === currentLocale }]}
            role="option"
            aria-selected={locale === currentLocale}
            data-locale={locale}
          >
            <span class="sidebar-lang-option-code">{locale.toUpperCase()}</span>
            <span class="sidebar-lang-option-name">{localeNames[locale]}</span>
            {locale === currentLocale && (
              <svg class="sidebar-lang-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            )}
          </a>
        ))}
      </div>
    </div>

    <!-- Theme toggle -->
    <div class="theme-controls">
      <button
        type="button"
        class="theme-btn"
        id="sidebar-theme-toggle"
        aria-label="Toggle dark mode"
      >
        <Icon name="sun" className="theme-icon-light" aria-hidden={true} client:only="react" />
        <Icon name="moon" className="theme-icon-dark" aria-hidden={true} client:only="react" />
      </button>
    </div>
  </div>
</aside>

<script lang="ts">
  const sidebarElement = document.querySelector('.sidebar');
  const sidebarDataset = sidebarElement?.dataset;
  // iconNameMap now only contains aliases (non-trivial mappings like cog → settings)
  const iconAliases = sidebarDataset?.iconNameMap
    ? new Map(Object.entries(JSON.parse(sidebarDataset.iconNameMap)))
    : new Map();
  const iconifyMap = sidebarDataset?.iconMap
    ? new Map(Object.entries(JSON.parse(sidebarDataset.iconMap)))
    : new Map();
  const iconSvgCache = new Map();
  const iconSvgRequests = new Map();

  // Convert kebab-case to camelCase: 'folder-open' → 'folderOpen'
  function kebabToCamel(str) {
    return str.replace(/-([a-z0-9])/g, (_, c) => c.toUpperCase());
  }

  // Cache for loaded folder content
  const folderCache = new Map();

  // Get current locale from page or default to 'en'
  function getCurrentLocale() {
    // Try to get from URL path (e.g., /en/docs/... or /es/docs/...)
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    const knownLocales = ['en', 'es', 'fr', 'de', 'pt', 'it', 'ja', 'zh', 'ko'];
    for (const part of pathParts) {
      if (knownLocales.includes(part)) {
        return part;
      }
    }
    // Try to get from language selector
    const langBtn = document.querySelector('.sidebar-lang-code');
    if (langBtn) {
      const code = langBtn.textContent?.trim().toUpperCase();
      if (code && knownLocales.includes(code.toLowerCase())) {
        return code.toLowerCase();
      }
    }
    return 'en';
  }

  // Fetch folder content from CMS API
  async function fetchFolderContent(collection, folder) {
    const locale = getCurrentLocale();
    const cacheKey = `${collection}/${folder}/${locale}`;
    const cached = folderCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      // Use CMS API directly (server-rendered endpoint, works with static builds)
      const sidebar = document.querySelector('.sidebar');
      const cmsUrl = sidebar?.dataset?.cmsUrl || '';
      const apiUrl = cmsUrl
        ? `${cmsUrl}/api/docs/navigation?collection=${collection}&folder=${folder}&locale=${locale}`
        : `/api/navigation?collection=${collection}&folder=${folder}&locale=${locale}`;
      const response = await fetch(apiUrl);
      if (!response.ok) throw new Error('Failed to fetch');
      const data = await response.json();
      const items = data.items || [];
      folderCache.set(cacheKey, items);
      return items;
    } catch (error) {
      console.error('Failed to fetch folder content:', error);
      return [];
    }
  }

  // Format title from path segment
  function formatTitle(segment) {
    return segment
      .replace(/-/g, ' ')
      .replace(/_/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase());
  }

  function resolveIconName(iconName, isFolder = false) {
    if (!iconName) return isFolder ? 'folder' : 'document';
    const normalized = iconName.toLowerCase();
    // 1. Check aliases (non-trivial mappings like cog → settings)
    const alias = iconAliases.get(normalized);
    if (alias) return alias;
    // 2. Auto-convert kebab→camelCase, check if valid in iconMap
    const camel = kebabToCamel(normalized);
    if (iconifyMap.has(camel)) return camel;
    // 3. Check raw in iconMap (single-word keys)
    if (iconifyMap.has(normalized)) return normalized;
    // 4. Fallback
    return isFolder ? 'folder' : 'document';
  }

  function resolveIconifyName(iconName, isFolder = false) {
    const resolved = resolveIconName(iconName, isFolder);
    return iconifyMap.get(resolved) || iconifyMap.get(isFolder ? 'folder' : 'document') || '';
  }

  function renderIcon(iconName, className = '', isFolder = false) {
    const iconifyName = resolveIconifyName(iconName, isFolder);
    if (!iconifyName) return '';
    return `<span class="${className}" data-iconify="${iconifyName}"></span>`;
  }

  function renderIconByName(iconifyName, className = '', style = '') {
    if (!iconifyName) return '';
    const styleAttr = style ? ` style="${style}"` : '';
    return `<span class="${className}" data-iconify="${iconifyName}"${styleAttr}></span>`;
  }

  // Custom icon SVG bodies (same as registered in Icon.tsx via addIcon)
  const customIconSvgs = {
    'custom:apple-logo': '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"><path d="M12 5.75C12 3.75 13.5 1.75 15.5 1.75C15.5 3.75 14 5.75 12 5.75Z"/><path d="M12.5 8.09001C11.9851 8.09001 11.5867 7.92646 11.1414 7.74368C10.5776 7.51225 9.93875 7.25 8.89334 7.25C7.02235 7.25 4 8.74945 4 12.7495C4 17.4016 7.10471 22.25 9.10471 22.25C9.77426 22.25 10.3775 21.9871 10.954 21.7359C11.4815 21.5059 11.9868 21.2857 12.5 21.2857C13.0132 21.2857 13.5185 21.5059 14.046 21.7359C14.6225 21.9871 15.2257 22.25 15.8953 22.25C17.2879 22.25 18.9573 19.8992 20 16.9008C18.3793 16.2202 17.338 14.618 17.338 12.75C17.338 11.121 18.2036 10.0398 19.5 9.25C18.5 7.75 17.0134 7.25 15.9447 7.25C14.8993 7.25 14.2604 7.51225 13.6966 7.74368C13.2514 7.92646 13.0149 8.09001 12.5 8.09001Z"/></g></svg>',
    'custom:apple-finder': '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"><path d="M2.5 12C2.5 7.52166 2.5 5.28249 3.89124 3.89124C5.28249 2.5 7.52166 2.5 12 2.5C16.4783 2.5 18.7175 2.5 20.1088 3.89124C21.5 5.28249 21.5 7.52166 21.5 12C21.5 16.4783 21.5 18.7175 20.1088 20.1088C18.7175 21.5 16.4783 21.5 12 21.5C7.52166 21.5 5.28249 21.5 3.89124 20.1088C2.5 18.7175 2.5 16.4783 2.5 12Z"/><path d="M7 8V10"/><path d="M17 8V10"/><path d="M7 16.5C10.5 18.5 13.5 18.5 17 16.5"/><path d="M12.9896 2.5C12.1238 3.78525 10.5163 7.71349 10.0737 11.5798C9.98097 12.3899 9.9346 12.795 10.1905 13.1176C10.2151 13.1486 10.2474 13.1843 10.2757 13.212C10.5708 13.5 11.0149 13.5 11.9031 13.5C12.3889 13.5 12.6317 13.5 12.7766 13.6314C12.7923 13.6457 12.8051 13.6588 12.819 13.6748C12.9468 13.8225 12.9383 14.072 12.9212 14.5709C12.8685 16.1156 12.9401 19.0524 14 21.5"/></g></svg>',
    'custom:windows-logo': '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.0136 3.99538L8.01361 4.99036C5.61912 5.38744 4.42188 5.58597 3.71094 6.421C3 7.25602 3 8.46368 3 10.879L3 13.121C3 15.5363 3 16.744 3.71094 17.579C4.42188 18.414 5.61913 18.6126 8.01361 19.0096L14.0136 20.0046C17.2567 20.5424 18.8782 20.8113 19.9391 19.9171C21 19.023 21 17.3873 21 14.116V9.88402C21 6.6127 21 4.97704 19.9391 4.08286C18.8782 3.18868 17.2567 3.45758 14.0136 3.99538Z"/><path d="M11 4.5V19.5M3 12H21"/></g></svg>',
    'custom:android-robot': '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M6.5 9.5C6.5 6.46243 8.96243 4 12 4C15.0376 4 17.5 6.46243 17.5 9.5V16C17.5 17.4142 17.5 18.1213 17.0607 18.5607C16.6213 19 15.9142 19 14.5 19H9.5C8.08579 19 7.37868 19 6.93934 18.5607C6.5 18.1213 6.5 17.4142 6.5 16V9.5Z"/><path d="M20 11V17"/><path d="M15 19V22"/><path d="M9 19V22"/><path d="M4 11V17"/><path d="M10 4L8.5 2M14 4L15.5 2"/><path d="M6.5 10H17.5"/></g></svg>',
  };

  async function loadIconSvg(iconifyName) {
    const cached = iconSvgCache.get(iconifyName);
    if (cached) return cached;
    // Resolve custom icons locally (not available on Iconify API)
    if (customIconSvgs[iconifyName]) {
      const svg = customIconSvgs[iconifyName];
      iconSvgCache.set(iconifyName, svg);
      return svg;
    }
    const inFlight = iconSvgRequests.get(iconifyName);
    if (inFlight) return inFlight;
    const request = fetch(`https://api.iconify.design/${iconifyName}.svg`)
      .then(res => (res.ok ? res.text() : ''))
      .then(svg => {
        iconSvgCache.set(iconifyName, svg);
        return svg;
      })
      .catch(() => '');
    iconSvgRequests.set(iconifyName, request);
    return request;
  }

  async function hydrateIcons(container) {
    const placeholders = Array.from(container.querySelectorAll('[data-iconify]'));
    if (placeholders.length === 0) return;
    await Promise.all(placeholders.map(async placeholder => {
      const iconifyName = placeholder.dataset?.iconify;
      if (!iconifyName) return;
      const svg = await loadIconSvg(iconifyName);
      if (!svg) return;
      placeholder.innerHTML = svg;
    }));
  }

  // Check if any item or its descendants are active (recursive)
  function hasActiveDescendant(items, currentPath) {
    const normCurrent = currentPath.replace(/\/+$/, '') || '/';
    for (const item of items) {
      const normItem = (item.href || '').replace(/\/+$/, '') || '/';
      if (normCurrent === normItem || normCurrent.startsWith(normItem + '/')) {
        return true;
      }
      if (item.children && hasActiveDescendant(item.children, currentPath)) {
        return true;
      }
    }
    return false;
  }

  // Render folder navigation tree
  function renderFolderTree(items, currentPath, depth = 0) {
    if (!items || items.length === 0) return '';
    const normCurrent = currentPath.replace(/\/+$/, '') || '/';

    return items.map(item => {
      const normItem = (item.href || '').replace(/\/+$/, '') || '/';
      const isActive = normCurrent === normItem || normCurrent.startsWith(normItem + '/');
      const isFolder = item.type === 'folder';
      const paddingLeft = 0.75 + (depth * 0.75);

      if (isFolder && item.children) {
        // Check recursively for active items in all descendants OR if the folder itself is active
        const hasActiveChild = hasActiveDescendant(item.children, currentPath);
        const isSelfActive = normCurrent === normItem;
        const shouldExpand = isActive || hasActiveChild;
        const isTopLevel = depth === 0;
        const chevronStyle = shouldExpand ? 'transform: rotate(180deg)' : '';
        const chevronIcon = iconifyMap.get('chevronDown') || '';
        const folderClosedIcon = resolveIconifyName(item.icon, true);
        const folderOpenIcon = iconifyMap.get('folderOpen') || '';
        const iconLower = (item.icon || '').toLowerCase();
        const itemHasFolderIcon = !item.icon || iconLower === 'folder' || iconLower === 'folder-open' || iconLower === 'folder-tree' || iconLower === 'folder-plus';
        const showChevron = isTopLevel || !itemHasFolderIcon;

        return `
          <div class="folder-group" data-folder-group>
            <div
              class="folder-toggle ${shouldExpand ? 'has-active' : ''}"
              data-folder-toggle
              aria-expanded="${shouldExpand ? 'true' : 'false'}"
              style="padding-left: ${paddingLeft}rem"
            >
              <a href="${item.href || '#'}" class="folder-toggle-link ${isSelfActive ? 'active' : ''}">
                ${isTopLevel
                  ? renderIcon(item.icon, 'folder-icon', true)
                  : itemHasFolderIcon
                    ? `<span class="folder-icon folder-icon-closed" data-iconify="${folderClosedIcon}" style="${shouldExpand ? 'display:none' : ''}"></span>
                       <span class="folder-icon folder-icon-open" data-iconify="${folderOpenIcon}" style="${shouldExpand ? '' : 'display:none'}"></span>`
                    : renderIcon(item.icon, 'folder-icon', true)
                }
                <span class="folder-label">${item.title || formatTitle(item.name)}</span>
              </a>
              ${showChevron
                ? `<button type="button" class="folder-chevron-btn" data-folder-chevron aria-label="Toggle expand">
                    ${renderIconByName(chevronIcon, 'folder-chevron', chevronStyle)}
                  </button>`
                : ''
              }
            </div>
            <div class="folder-content" data-folder-content style="${shouldExpand ? '' : 'display: none'}">
              ${renderFolderTree(item.children, currentPath, depth + 1)}
            </div>
          </div>
        `;
      } else {
        const methodBadge = item.method
          ? `<span class="sidebar-method-badge method-${item.method.toLowerCase()}">${item.method}</span>`
          : renderIcon(item.icon, 'folder-item-icon', false);
        return `
          <a
            href="${item.href}"
            class="folder-item ${isActive ? 'active' : ''}"
            style="padding-left: ${paddingLeft}rem"
          >
            ${methodBadge}
            <span class="folder-item-label">${item.title || formatTitle(item.name)}</span>
          </a>
        `;
      }
    }).join('');
  }

  // Initialize folder toggle handlers
  function initFolderToggles(container) {
    const EXPAND_KEY = 'sidebar_expanded';
    function getExpandedSet() {
      try {
        return new Set(JSON.parse(sessionStorage.getItem(EXPAND_KEY) || '[]'));
      } catch { return new Set(); }
    }
    function saveExpandedSet(set) {
      sessionStorage.setItem(EXPAND_KEY, JSON.stringify([...set]));
    }

    const expandedSet = getExpandedSet();
    const folderGroups = container.querySelectorAll('[data-folder-group]');
    folderGroups.forEach(group => {
      const toggle = group.querySelector('[data-folder-toggle]');
      const content = group.querySelector('[data-folder-content]');
      const chevronBtn = toggle?.querySelector('[data-folder-chevron]');
      const chevron = toggle?.querySelector('.folder-chevron');
      const iconClosed = toggle?.querySelector('.folder-icon-closed');
      const iconOpen = toggle?.querySelector('.folder-icon-open');

      if (!toggle || !content) return;

      // Get key from link href or label text
      const link = toggle.querySelector('a');
      const key = link?.getAttribute('href') || toggle.textContent.trim();

      function updateExpandState(expanded) {
        if (chevron) {
          chevron.style.transform = expanded ? 'rotate(180deg)' : 'rotate(0deg)';
        }
        if (iconClosed) iconClosed.style.display = expanded ? 'none' : '';
        if (iconOpen) iconOpen.style.display = expanded ? '' : 'none';
      }

      // Restore persisted expand state
      if (key && expandedSet.has(key)) {
        const serverExpanded = toggle.getAttribute('aria-expanded') === 'true';
        if (!serverExpanded) {
          toggle.setAttribute('aria-expanded', 'true');
          updateExpandState(true);
          content.style.display = 'block';
        }
      }

      // For folders with chevron: chevron button toggles
      if (chevronBtn) {
        chevronBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
          const nowExpanded = !isExpanded;
          toggle.setAttribute('aria-expanded', nowExpanded.toString());
          updateExpandState(nowExpanded);
          content.style.display = isExpanded ? 'none' : 'block';

          const current = getExpandedSet();
          if (nowExpanded) current.add(key);
          else current.delete(key);
          saveExpandedSet(current);
        });
      }

      // For sub-folders without chevron: clicking the link toggles expand
      if (!chevronBtn && (iconClosed || iconOpen)) {
        link?.addEventListener('click', (e) => {
          e.preventDefault();
          const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
          const nowExpanded = !isExpanded;
          toggle.setAttribute('aria-expanded', nowExpanded.toString());
          updateExpandState(nowExpanded);
          content.style.display = isExpanded ? 'none' : 'block';

          const current = getExpandedSet();
          if (nowExpanded) current.add(key);
          else current.delete(key);
          saveExpandedSet(current);
        });
      }
    });
  }

  // Load product navigation
  async function loadProductNav(productBtn) {
    const container = document.getElementById('product-nav-container');
    if (!container) return;

    const folder = productBtn.dataset.productFolder;
    const collection = productBtn.dataset.productCollection || 'docs';

    if (!folder) {
      container.innerHTML = '<div class="product-nav-empty">No folder configured for this product</div>';
      return;
    }

    // Show skeleton loading
    container.innerHTML = `
      <div class="product-nav-skeleton">
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
            <div class="skeleton-bar skeleton-item"></div>
          </div>
        </div>
        <div class="skeleton-folder">
          <div class="skeleton-bar skeleton-folder-title short"></div>
          <div class="skeleton-children">
            <div class="skeleton-bar skeleton-item"></div>
            <div class="skeleton-bar skeleton-item short"></div>
          </div>
        </div>
      </div>
    `;

    // Fetch content
    const items = await fetchFolderContent(collection, folder);
    const currentPath = window.location.pathname;

    if (items.length === 0) {
      container.innerHTML = '<div class="product-nav-empty">No content found</div>';
      return;
    }

    // Render navigation
    container.innerHTML = `<div class="product-nav-content">${renderFolderTree(items, currentPath)}</div>`;

    // Initialize toggle handlers
    initFolderToggles(container);

    // Hydrate iconify placeholders with actual SVGs
    await hydrateIcons(container);
  }

  /**
   * Load tab navigation content
   * - Aborts previous request if new one comes in (prevents race conditions)
   * - Uses cache for instant re-renders of visited tabs
   * - Minimal DOM updates
   */
  let currentLoadController = null;

  async function loadTabNav(folder, collection) {
    const container = document.getElementById('tab-nav-container');
    if (!container || !folder) return;

    // Abort any in-flight request
    currentLoadController?.abort();
    currentLoadController = new AbortController();

    // Check cache first for instant render
    const locale = getCurrentLocale();
    const cacheKey = `${collection}/${folder}/${locale}`;
    const cached = folderCache.get(cacheKey);

    if (cached) {
      renderNav(container, cached);
      return;
    }

    // Show minimal loading indicator
    container.setAttribute('aria-busy', 'true');

    try {
      const items = await fetchFolderContent(collection, folder);
      renderNav(container, items);
    } catch (e) {
      const isAbort =
        e &&
        typeof e === 'object' &&
        'name' in e &&
        e.name === 'AbortError';
      if (!isAbort) {
        container.innerHTML = '<div class="tab-nav-empty">Failed to load</div>';
      }
    } finally {
      container.removeAttribute('aria-busy');
    }
  }

  function renderNav(container, items) {
    if (items.length === 0) {
      container.innerHTML = '<div class="tab-nav-empty">No content found</div>';
      return;
    }
    container.innerHTML = `<div class="tab-nav-content">${renderFolderTree(items, location.pathname)}</div>`;
    initFolderToggles(container);

    // Hydrate iconify placeholders with actual SVGs
    hydrateIcons(container);
  }

  function initSidebar() {
    // Product selector
    const productBtns = document.querySelectorAll('.product-btn');
    productBtns.forEach(btn => {
      btn.addEventListener('click', async () => {
        // Update active state
        productBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        // Load product navigation
        await loadProductNav(btn);
      });
    });

    // Load default active product navigation on page load
    const activeProduct = document.querySelector('.product-btn.active');
    if (activeProduct) {
      loadProductNav(activeProduct);
    }

    // Tab navigation - listen for tabChange events from header
    const tabContainer = document.getElementById('tab-nav-container');
    if (tabContainer) {
      // Load initial tab content from localStorage or default
      const storedTab = localStorage.getItem('docs_active_tab');
      let initialTab = null;

      if (storedTab) {
        try {
          initialTab = JSON.parse(storedTab);
        } catch (e) {
          // Ignore parse errors
        }
      }

      // If no stored tab, use default from data attribute
      if (!initialTab) {
        const tabsData = tabContainer.dataset.tabs;
        if (tabsData) {
          try {
            const tabs = JSON.parse(tabsData);
            const defaultTab = tabs.find((t) => t.defaultActive) || tabs[0];
            if (defaultTab) {
              initialTab = {
                id: defaultTab.id,
                folder: defaultTab.folder,
                collection: defaultTab.collection || 'docs'
              };
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
      }

      // Load initial tab navigation
      if (initialTab?.folder) {
        loadTabNav(initialTab.folder, initialTab.collection);
      }

      // Listen for tab changes from header
      window.addEventListener('tabChange', (e) => {
        const detail = e.detail || {};
        const { folder, collection } = detail || {};
        if (folder) loadTabNav(folder, collection);
      });
    }

    // Sidebar expand state persistence
    const EXPAND_KEY = 'sidebar_expanded';
    function getExpandedSet() {
      try {
        return new Set(JSON.parse(sessionStorage.getItem(EXPAND_KEY) || '[]'));
      } catch { return new Set(); }
    }
    function saveExpandedSet(set) {
      sessionStorage.setItem(EXPAND_KEY, JSON.stringify([...set]));
    }
    function getToggleKey(toggle) {
      const link = toggle.querySelector('a');
      return link?.getAttribute('href') || toggle.textContent.trim();
    }

    // Navigation toggle (for static navigation)
    const expandedSet = getExpandedSet();
    const groups = document.querySelectorAll('[data-nav-group]');
    groups.forEach(group => {
      const toggle = group.querySelector('[data-nav-toggle]');
      const content = group.querySelector('[data-nav-content]');
      const chevronBtn = toggle?.querySelector('[data-nav-chevron]');
      const chevron = toggle?.querySelector('.nav-chevron, .nav-chevron-sub');
      const isSubfolder = toggle?.hasAttribute('data-subfolder-toggle');

      if (!toggle || !content) return;

      const key = getToggleKey(toggle);

      // Restore persisted expand state
      if (key && expandedSet.has(key)) {
        const serverExpanded = toggle.getAttribute('aria-expanded') === 'true';
        if (!serverExpanded) {
          toggle.setAttribute('aria-expanded', 'true');
          if (chevron) chevron.style.transform = 'rotate(180deg)';
          content.style.display = 'block';
        }
      }

      function doToggle() {
        const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
        const nowExpanded = !isExpanded;
        toggle.setAttribute('aria-expanded', nowExpanded.toString());
        if (chevron) chevron.style.transform = nowExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
        content.style.display = isExpanded ? 'none' : 'block';

        // Persist state
        const current = getExpandedSet();
        if (nowExpanded) current.add(key);
        else current.delete(key);
        saveExpandedSet(current);
      }

      // Top-level folders: chevron button toggles expand/collapse
      if (chevronBtn) {
        chevronBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          doToggle();
        });
      }

      // Sub-folders without chevron: clicking the link/label toggles expand
      if (isSubfolder && !chevronBtn) {
        const link = toggle.querySelector('a, [data-subfolder-link]');
        if (link) {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            doToggle();

            const current = getExpandedSet();
            if (nowExpanded) current.add(key);
            else current.delete(key);
            saveExpandedSet(current);
          });
        }
      }
    });

    // Language selector
    const langSelector = document.querySelector('[data-language-selector]');
    const langToggle = langSelector?.querySelector('[data-language-toggle]');
    const langDropdown = langSelector?.querySelector('[data-language-dropdown]');

    if (langToggle && langDropdown && langSelector) {
      langToggle.addEventListener('click', () => {
        const isOpen = langToggle.getAttribute('aria-expanded') === 'true';
        langToggle.setAttribute('aria-expanded', (!isOpen).toString());
        langSelector.classList.toggle('open', !isOpen);
      });

      // Close on click outside
      document.addEventListener('click', (e) => {
        if (e.target && !langSelector.contains(e.target)) {
          langToggle.setAttribute('aria-expanded', 'false');
          langSelector.classList.remove('open');
        }
      });
    }

    // Theme toggle
    const themeToggle = document.getElementById('sidebar-theme-toggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        const isDark = document.documentElement.classList.toggle('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
      });
    }
  }

  // Run on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSidebar);
  } else {
    initSidebar();
  }
  document.addEventListener('astro:after-swap', initSidebar);
</script>

<style>
  .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: var(--sidebar-width);
    background: transparent;
    border: none;
    z-index: 40;
    display: flex;
    flex-direction: column;
    overflow: visible;
    transition: transform 0.3s ease;
  }

  .sidebar-header {
    height: var(--header-height);
    display: flex;
    align-items: center;
    padding: 0 1.25rem;
    flex-shrink: 0;
  }

  .sidebar-logo {
    display: flex;
    align-items: center;
  }

  /* Product Selector */
  .product-selector {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    padding: 0 1rem 0.75rem;
    border-bottom: 1px solid var(--color-border);
  }

  .product-btn {
    display: flex;
    align-items: center;
    gap: 0.625rem;
    padding: 0.5rem 0.75rem;
    font-size: 0.8125rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    background: transparent;
    border: 1px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.15s ease;
    text-align: left;
  }

  .product-btn:hover {
    color: var(--color-menu-item-hover-text);
    background: var(--color-menu-item-hover-bg);
  }

  .product-btn.active {
    color: var(--color-menu-item-active-text, var(--color-primary));
    background: var(--color-menu-item-active-bg, var(--color-primary-10));
    border-color: var(--color-border);
  }

  :global(.dark) .product-btn.active {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
    background: var(--color-menu-item-active-bg, var(--color-accent-10));
    border-color: var(--color-border);
  }

  .product-icon {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    opacity: 0.7;
  }

  .product-btn.active .product-icon {
    opacity: 1;
  }

  .product-label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Product Navigation Container */
  .product-nav-container {
    flex: 1;
    overflow-y: auto;
    padding: 0.75rem 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: transparent transparent;
  }

  .product-nav-container::-webkit-scrollbar {
    width: 6px;
  }

  .product-nav-container::-webkit-scrollbar-track {
    background: transparent;
  }

  .product-nav-container::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 9999px;
  }

  .product-nav-container:hover {
    scrollbar-color: var(--color-border) transparent;
  }

  .product-nav-container:hover::-webkit-scrollbar-thumb {
    background-color: var(--color-border);
  }

  /* Skeleton Loading Styles */
  .product-nav-skeleton,
  .tab-nav-skeleton,
  :global(.product-nav-skeleton),
  :global(.tab-nav-skeleton) {
    padding: 0.75rem;
  }

  .skeleton-folder {
    margin-bottom: 0.75rem;
  }

  .skeleton-bar {
    height: 0.625rem;
    border-radius: 0.25rem;
    background: linear-gradient(
      90deg,
      var(--color-border) 0%,
      var(--color-background-secondary) 50%,
      var(--color-border) 100%
    );
    background-size: 200% 100%;
    animation: skeleton-shimmer 1.5s ease-in-out infinite;
  }

  .skeleton-folder-title {
    width: 60%;
    height: 0.75rem;
    margin-bottom: 0.5rem;
    margin-left: 0.25rem;
  }

  .skeleton-folder-title.short {
    width: 45%;
  }

  .skeleton-children {
    padding-left: 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .skeleton-item {
    width: 80%;
  }

  .skeleton-item.short {
    width: 55%;
  }

  @keyframes skeleton-shimmer {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  .product-nav-empty,
  :global(.product-nav-empty) {
    padding: 1.5rem 1rem;
    text-align: center;
    color: var(--color-text-muted);
    font-size: 0.8125rem;
  }

  :global(.product-nav-content) {
    display: flex;
    flex-direction: column;
  }

  /* Folder Tree Styles - must be global for dynamic JS rendering */
  :global(.folder-group) {
    margin-bottom: 0.125rem;
  }

  :global(.folder-toggle) {
    display: flex;
    align-items: center;
    width: 100%;
    font-size: 0.8125rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    background: transparent;
    border: none;
    border-radius: 0.375rem;
    transition: all 0.15s ease;
  }

  :global(.folder-toggle:hover) {
    background: var(--color-menu-item-hover-bg);
  }

  :global(.folder-toggle.has-active) {
    color: var(--color-text-primary);
  }

  :global(.folder-toggle-link) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
    min-width: 0;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    color: inherit;
    text-decoration: none;
    cursor: pointer;
  }

  :global(.folder-toggle-link:hover) {
    color: var(--color-menu-item-hover-text);
  }

  :global(.folder-chevron-btn) {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 0.75rem;
    background: transparent;
    border: none;
    cursor: pointer;
    border-radius: 0 0.375rem 0.375rem 0;
    transition: all 0.15s ease;
  }

  :global(.folder-chevron-btn:hover) {
    background: transparent;
  }

  :global(.folder-icon) {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    color: var(--color-text-muted);
  }

  :global(.folder-toggle-link:hover .folder-icon),
  :global(.folder-toggle.has-active .folder-icon),
  :global(.folder-toggle-link.active .folder-icon) {
    color: var(--color-primary);
  }

  :global(.folder-toggle-link.active) {
    color: var(--color-menu-item-active-text, var(--color-primary));
    font-weight: 600;
  }

  :global(.dark .folder-toggle-link.active) {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
  }

  :global(.folder-label) {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  :global(.folder-chevron) {
    width: 0.875rem;
    height: 0.875rem;
    opacity: 0.4;
    transition: transform 0.2s ease, opacity 0.15s ease;
    flex-shrink: 0;
  }

  :global(.folder-chevron-btn:hover .folder-chevron) {
    opacity: 0.7;
  }

  :global(.folder-content) {
    overflow: hidden;
  }

  /* Auto-tree subfolder icon swap via aria-expanded */
  :global([data-folder-toggle] .folder-icon-open) {
    display: none;
  }
  :global([data-folder-toggle][aria-expanded="true"] .folder-icon-closed) {
    display: none;
  }
  :global([data-folder-toggle][aria-expanded="true"] .folder-icon-open) {
    display: initial;
  }

  :global(.folder-item) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    padding-right: 0.75rem;
    font-size: 0.8125rem;
    color: var(--color-text-tertiary);
    border-radius: 0.375rem;
    transition: all 0.15s ease;
    text-decoration: none;
  }

  :global(.folder-item:hover) {
    color: var(--color-menu-item-hover-text);
    background: var(--color-menu-item-hover-bg);
  }

  :global(.folder-item.active) {
    color: var(--color-menu-item-active-text, var(--color-primary));
    background: var(--color-menu-item-active-bg, var(--color-primary-10));
    font-weight: 500;
  }

  :global(.dark .folder-item.active) {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
    background: var(--color-menu-item-active-bg, var(--color-accent-10));
  }

  :global(.folder-item-icon) {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    opacity: 0.5;
  }

  :global(.folder-item:hover .folder-item-icon),
  :global(.folder-item.active .folder-item-icon) {
    opacity: 1;
  }

  :global(.folder-item-label) {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Hide static content when products or tabs are active */
  .sidebar-content.has-products,
  .sidebar-content.has-tabs {
    display: none;
  }

  /* Tab Navigation Container */
  .tab-nav-container {
    flex: 1;
    overflow-y: auto;
    padding: 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: transparent transparent;
  }

  .tab-nav-container::-webkit-scrollbar {
    width: 6px;
  }

  .tab-nav-container::-webkit-scrollbar-track {
    background: transparent;
  }

  .tab-nav-container::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 9999px;
  }

  .tab-nav-container:hover {
    scrollbar-color: var(--color-border) transparent;
  }

  .tab-nav-container:hover::-webkit-scrollbar-thumb {
    background-color: var(--color-border);
  }

  .tab-nav-empty,
  :global(.tab-nav-empty) {
    padding: 1.5rem 1rem;
    text-align: center;
    color: var(--color-text-muted);
    font-size: 0.8125rem;
  }

  :global(.tab-nav-content) {
    display: flex;
    flex-direction: column;
  }

  .sidebar-content {
    flex: 1;
    overflow-y: auto;
    padding: 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: transparent transparent;
  }

  .sidebar-content::-webkit-scrollbar {
    width: 6px;
  }

  .sidebar-content::-webkit-scrollbar-track {
    background: transparent;
  }

  .sidebar-content::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 9999px;
  }

  .sidebar-content:hover {
    scrollbar-color: var(--color-border) transparent;
  }

  .sidebar-content:hover::-webkit-scrollbar-thumb {
    background-color: var(--color-border);
  }

  .sidebar-nav-group {
    margin-bottom: 0.125rem;
  }

  .sidebar-nav-group-title {
    display: flex;
    align-items: center;
    width: 100%;
    font-size: 0.8125rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    background: transparent;
    border: none;
    border-radius: 0.375rem;
    transition: all 0.15s ease;
  }

  .sidebar-nav-group-title:hover {
    background-color: var(--color-menu-item-hover-bg);
  }

  .sidebar-nav-group-title.has-active {
    color: var(--color-text-primary);
  }

  .sidebar-nav-group-link {
    text-decoration: none;
    color: inherit;
  }

  /* Shared styles for nav toggle link/chevron split */
  .nav-toggle-link {
    display: flex;
    align-items: center;
    flex: 1;
    min-width: 0;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    color: inherit;
    text-decoration: none;
    cursor: pointer;
  }

  .nav-toggle-link:hover {
    color: var(--color-menu-item-hover-text);
  }

  .sidebar-nav-group-title.active .nav-toggle-link {
    color: var(--color-menu-item-active-text, var(--color-primary));
    font-weight: 600;
  }

  :global(.dark) .sidebar-nav-group-title.active .nav-toggle-link {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
  }

  .sidebar-nav-group-title.active .group-title-icon {
    color: var(--color-primary);
  }

  .nav-chevron-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 0.75rem;
    background: transparent;
    border: none;
    cursor: pointer;
    border-radius: 0 0.375rem 0.375rem 0;
    transition: all 0.15s ease;
  }

  .nav-chevron-btn:hover {
    background: transparent;
  }

  .group-title-content {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
  }

  .group-title-icon {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    color: var(--color-text-muted);
  }

  .nav-toggle-link:hover .group-title-icon {
    color: var(--color-primary);
  }

  .nav-chevron {
    width: 0.875rem;
    height: 0.875rem;
    opacity: 0.4;
    transition: transform 0.2s ease, opacity 0.15s ease;
  }

  .nav-chevron-btn:hover .nav-chevron {
    opacity: 0.7;
  }

  .nav-group-content {
    overflow: hidden;
  }

  .nav-group-content ul {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .sidebar-nav-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    padding-right: 0.75rem;
    font-size: 0.8125rem;
    color: var(--color-text-tertiary);
    border-radius: 0.375rem;
    transition: all 0.15s ease;
    text-decoration: none;
  }

  .sidebar-nav-item:hover {
    color: var(--color-menu-item-hover-text);
    background-color: var(--color-menu-item-hover-bg);
  }

  .sidebar-nav-item.active {
    color: var(--color-menu-item-active-text, var(--color-primary));
    background: var(--color-menu-item-active-bg, var(--color-primary-10));
    font-weight: 500;
  }

  :global(.dark) .sidebar-nav-item.active {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
    background: var(--color-menu-item-active-bg, var(--color-accent-10));
  }

  .nav-item-icon {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    opacity: 0.5;
  }

  .sidebar-nav-item:hover .nav-item-icon {
    opacity: 1;
  }

  .sidebar-nav-item.active .nav-item-icon {
    opacity: 1;
  }

  .nav-item-label {
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .sidebar-nav-subgroup {
    margin-bottom: 0.125rem;
  }

  .sidebar-nav-subgroup-title {
    display: flex;
    align-items: center;
    width: 100%;
    font-size: 0.8125rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    background: transparent;
    border: none;
    border-radius: 0.375rem;
    transition: all 0.15s ease;
  }

  .sidebar-nav-subgroup-title:hover {
    background-color: var(--color-menu-item-hover-bg);
  }

  .sidebar-nav-subgroup-title .nav-toggle-link {
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
  }

  .sidebar-nav-subgroup-link {
    text-decoration: none;
    color: inherit;
  }

  .sidebar-nav-subgroup-title.active .nav-toggle-link {
    color: var(--color-menu-item-active-text, var(--color-primary));
    font-weight: 600;
  }

  :global(.dark) .sidebar-nav-subgroup-title.active .nav-toggle-link {
    color: var(--color-menu-item-active-text, var(--color-accent-light));
  }

  .sidebar-nav-subgroup-title.active .group-title-icon {
    color: var(--color-primary);
  }

  .nav-chevron-sub {
    width: 0.875rem;
    height: 0.875rem;
    opacity: 0.4;
    transition: transform 0.2s ease, opacity 0.15s ease;
  }

  .nav-chevron-btn:hover .nav-chevron-sub {
    opacity: 0.7;
  }

  .nav-subgroup-content {
    list-style: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  .sidebar-nav-item-nested {
    font-size: 0.8125rem;
  }

  .sidebar-nav-item-nested.active {
    background-color: var(--color-menu-item-active-bg, var(--color-primary-5));
  }

  :global(.dark) .sidebar-nav-item-nested.active {
    background-color: var(--color-menu-item-active-bg, var(--color-accent-10));
  }

  /* Subfolder icon swap: show closed folder when collapsed, open folder when expanded */
  [data-subfolder-toggle] :global(.subfolder-icon-open) {
    display: none;
  }
  [data-subfolder-toggle][aria-expanded="true"] :global(.subfolder-icon-closed) {
    display: none;
  }
  [data-subfolder-toggle][aria-expanded="true"] :global(.subfolder-icon-open) {
    display: initial;
  }

  /* Sidebar method badges for API endpoints */
  .sidebar-method-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.0625rem 0.3rem;
    border-radius: 0.25rem;
    font-size: 0.5625rem;
    font-weight: 700;
    font-family: 'JetBrains Mono', ui-monospace, monospace;
    text-transform: uppercase;
    letter-spacing: 0.02em;
    line-height: 1.2;
    flex-shrink: 0;
    min-width: 2rem;
    text-align: center;
  }

  /* Footer — fixed at bottom */
  .sidebar-footer {
    padding: 0.75rem 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
    border-top: 1px solid var(--color-border);
    margin-top: auto;
  }

  /* Language Selector — matches home header style */
  .sidebar-lang-selector {
    position: relative;
  }

  .sidebar-lang-btn {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.375rem 0.5rem;
    font-size: 0.8125rem;
    color: var(--color-text-secondary);
    background: transparent;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .sidebar-lang-btn:hover {
    color: var(--color-text-primary);
    background-color: var(--color-background-secondary);
  }

  .sidebar-lang-icon {
    width: 0.875rem;
    height: 0.875rem;
    opacity: 0.7;
  }

  .sidebar-lang-code {
    font-weight: 600;
    font-size: 0.75rem;
  }

  .sidebar-lang-chevron {
    width: 0.625rem;
    height: 0.625rem;
    opacity: 0.5;
    transition: transform 0.2s ease;
  }

  .sidebar-lang-selector.open .sidebar-lang-chevron {
    transform: rotate(180deg);
  }

  .sidebar-lang-dropdown {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 0.5rem;
    min-width: 140px;
    padding: 0.25rem;
    background: var(--color-bg-primary, #ffffff);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    opacity: 0;
    visibility: hidden;
    transform: translateY(0.5rem);
    transition: all 0.15s ease;
    z-index: 100;
  }

  :global(.dark) .sidebar-lang-dropdown {
    background: var(--color-bg-primary, #0b1220);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  }

  .sidebar-lang-selector.open .sidebar-lang-dropdown {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  .sidebar-lang-option {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4375rem 0.625rem;
    font-size: 0.75rem;
    color: var(--color-text-secondary);
    border-radius: 0.375rem;
    transition: all 0.15s ease;
    text-decoration: none;
  }

  .sidebar-lang-option:hover {
    color: var(--color-text-primary);
    background-color: var(--color-background-secondary);
  }

  .sidebar-lang-option.active {
    color: var(--color-primary);
    background-color: var(--color-primary-5, rgba(var(--color-primary-rgb, 0,0,0), 0.05));
    font-weight: 500;
  }

  .sidebar-lang-option-code {
    font-weight: 600;
    width: 1.5rem;
  }

  .sidebar-lang-option-name {
    flex: 1;
    color: var(--color-text-muted);
  }

  .sidebar-lang-option.active .sidebar-lang-option-name {
    color: var(--color-primary);
    opacity: 0.7;
  }

  .sidebar-lang-check {
    width: 0.875rem;
    height: 0.875rem;
    color: var(--color-primary);
  }

  /* Theme Controls */
  .theme-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .theme-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    color: var(--color-text-tertiary);
    background: transparent;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .theme-btn:hover {
    color: var(--color-menu-item-hover-text);
    background-color: var(--color-menu-item-hover-bg);
  }

  .theme-icon-light,
  .theme-icon-dark {
    width: 1.125rem;
    height: 1.125rem;
  }

  .theme-icon-dark {
    display: none;
  }

  :global(.dark) .theme-icon-light {
    display: none;
  }

  :global(.dark) .theme-icon-dark {
    display: block;
  }

  /* Mobile - needs background when open as overlay */
  @media (max-width: 1024px) {
    .sidebar {
      transform: translateX(-100%);
    }

    .sidebar.open {
      transform: translateX(0);
      background-color: var(--color-surface);
    }

    :global(.dark) .sidebar.open {
      background-color: var(--color-bg-primary);
    }
  }
</style>
