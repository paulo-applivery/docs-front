---
/**
 * Dynamic documentation page route with locale support
 * URL: docs.applivery.com/{locale}/{product}/{path}
 *
 * Phase 0 rewrite: Uses getCollection('docs') from Content Layer.
 * Zero network calls during rendering — all data is local.
 */

import { getCollection } from 'astro:content';
import DocLayout from '../../layouts/DocLayout.astro';
import ArchiveGrid from '../../components/ArchiveGrid.astro';
import { resolveMediaUrl, getAllSettings, getFolderSettings, type FolderSettingsMap } from '../../lib/cms';
import { processMarkdown } from '../../lib/markdown';
import {
  locales,
  isValidLocale,
  type Locale
} from '../../lib/i18n';
import {
  getIndexFolderPath,
  isIndexFile,
  extractSlugFromPath,
  extractLocaleFromPath,
  getPathPattern,
  getDocSlug,
  getDocUrl,
  extractHeadings,
  isValidSlug,
} from '../../lib/doc-helpers';
import { iconMap, type IconName } from '../../lib/icons';
import solarSubset from '../../assets/solar-icons-subset.json';

// ─── Icon rendering for archive folder cards ────────────────────────

const customIconBodies: Record<string, { body: string; width?: number; height?: number }> = {
  'custom:apple-logo': {
    body: '<g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"><path d="M12 5.75C12 3.75 13.5 1.75 15.5 1.75C15.5 3.75 14 5.75 12 5.75Z"/><path d="M12.5 8.09001C11.9851 8.09001 11.5867 7.92646 11.1414 7.74368C10.5776 7.51225 9.93875 7.25 8.89334 7.25C7.02235 7.25 4 8.74945 4 12.7495C4 17.4016 7.10471 22.25 9.10471 22.25C9.77426 22.25 10.3775 21.9871 10.954 21.7359C11.4815 21.5059 11.9868 21.2857 12.5 21.2857C13.0132 21.2857 13.5185 21.5059 14.046 21.7359C14.6225 21.9871 15.2257 22.25 15.8953 22.25C17.2879 22.25 18.9573 19.8992 20 16.9008C18.3793 16.2202 17.338 14.618 17.338 12.75C17.338 11.121 18.2036 10.0398 19.5 9.25C18.5 7.75 17.0134 7.25 15.9447 7.25C14.8993 7.25 14.2604 7.51225 13.6966 7.74368C13.2514 7.92646 13.0149 8.09001 12.5 8.09001Z"/></g>',
    width: 24, height: 24,
  },
  'custom:apple-finder': {
    body: '<g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"><path d="M2.5 12C2.5 7.52166 2.5 5.28249 3.89124 3.89124C5.28249 2.5 7.52166 2.5 12 2.5C16.4783 2.5 18.7175 2.5 20.1088 3.89124C21.5 5.28249 21.5 7.52166 21.5 12C21.5 16.4783 21.5 18.7175 20.1088 20.1088C18.7175 21.5 16.4783 21.5 12 21.5C7.52166 21.5 5.28249 21.5 3.89124 20.1088C2.5 18.7175 2.5 16.4783 2.5 12Z"/><path d="M7 8V10"/><path d="M17 8V10"/><path d="M7 16.5C10.5 18.5 13.5 18.5 17 16.5"/><path d="M12.9896 2.5C12.1238 3.78525 10.5163 7.71349 10.0737 11.5798C9.98097 12.3899 9.9346 12.795 10.1905 13.1176C10.2151 13.1486 10.2474 13.1843 10.2757 13.212C10.5708 13.5 11.0149 13.5 11.9031 13.5C12.3889 13.5 12.6317 13.5 12.7766 13.6314C12.7923 13.6457 12.8051 13.6588 12.819 13.6748C12.9468 13.8225 12.9383 14.072 12.9212 14.5709C12.8685 16.1156 12.9401 19.0524 14 21.5"/></g>',
    width: 24, height: 24,
  },
  'custom:windows-logo': {
    body: '<g fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.0136 3.99538L8.01361 4.99036C5.61912 5.38744 4.42188 5.58597 3.71094 6.421C3 7.25602 3 8.46368 3 10.879L3 13.121C3 15.5363 3 16.744 3.71094 17.579C4.42188 18.414 5.61913 18.6126 8.01361 19.0096L14.0136 20.0046C17.2567 20.5424 18.8782 20.8113 19.9391 19.9171C21 19.023 21 17.3873 21 14.116V9.88402C21 6.6127 21 4.97704 19.9391 4.08286C18.8782 3.18868 17.2567 3.45758 14.0136 3.99538Z"/><path d="M11 4.5V19.5M3 12H21"/></g>',
    width: 24, height: 24,
  },
  'custom:android-robot': {
    body: '<g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M6.5 9.5C6.5 6.46243 8.96243 4 12 4C15.0376 4 17.5 6.46243 17.5 9.5V16C17.5 17.4142 17.5 18.1213 17.0607 18.5607C16.6213 19 15.9142 19 14.5 19H9.5C8.08579 19 7.37868 19 6.93934 18.5607C6.5 18.1213 6.5 17.4142 6.5 16V9.5Z"/><path d="M20 11V17"/><path d="M15 19V22"/><path d="M9 19V22"/><path d="M4 11V17"/><path d="M10 4L8.5 2M14 4L15.5 2"/><path d="M6.5 10H17.5"/></g>',
    width: 24, height: 24,
  },
};

function renderIconSvg(name: IconName, className: string): string {
  const iconId = iconMap[name];
  if (!iconId) return '';
  let body = '';
  let width = 24;
  let height = 24;
  if (iconId.startsWith('custom:')) {
    const customIcon = customIconBodies[iconId];
    if (customIcon) { body = customIcon.body; width = customIcon.width || 24; height = customIcon.height || 24; }
  } else if (iconId.startsWith('solar:')) {
    const solarName = iconId.replace('solar:', '');
    const solarIcon = (solarSubset as any).icons?.[solarName];
    if (solarIcon) { body = solarIcon.body; width = solarIcon.width || (solarSubset as any).width || 24; height = solarIcon.height || (solarSubset as any).height || 24; }
  }
  if (!body) return '';
  return `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 ${width} ${height}" class="${className}" aria-hidden="true">${body}</svg>`;
}

const folderIconInference: Record<string, string> = {
  'android': 'androidRobot', 'ios': 'appleLogo', 'ipados': 'appleLogo',
  'ios-ipados': 'appleLogo', 'macos': 'appleFinder', 'tvos': 'appleLogo',
  'watchos': 'appleLogo', 'visionos': 'appleLogo', 'windows': 'windowsLogo',
  'oem-configs': 'settings', 'oem': 'settings', 'workspace': 'building', 'workspaces': 'building',
  'api': 'api',
};

const iconAliases: Record<string, string> = {
  'settings-2': 'settings', cog: 'settings', 'columns-3-cog': 'settings',
  'trash-2': 'trash', 'monitor-smartphone': 'smartphone', 'tablet-smartphone': 'tablet',
  iphone: 'smartphone', ipad: 'tablet', 'bar-chart-2': 'barChart',
  'android-robot': 'androidRobot', 'apple-logo': 'appleLogo', 'apple-finder': 'appleFinder',
  'windows-logo': 'windowsLogo',
};

function kebabToCamel(str: string): string {
  return str.replace(/-([a-z0-9])/g, (_, c: string) => c.toUpperCase());
}

function resolveIconName(iconName?: string): IconName {
  if (!iconName) return 'folder';
  const lower = iconName.toLowerCase();
  if (iconAliases[lower]) return iconAliases[lower] as IconName;
  const camel = kebabToCamel(lower);
  if (camel in iconMap) return camel as IconName;
  if (lower in iconMap) return lower as IconName;
  return 'folder';
}

function resolveFolderIcon(folderPath: string, docIcon?: string): string {
  // Extract last segment from folder path for inference
  const segments = folderPath.split('/').filter(Boolean);
  const folderKey = segments[segments.length - 1] || '';

  // If doc has a specific (non-generic) icon, use it
  const genericIcons = ['folder', 'folder-open', 'folder-tree', 'folder-plus'];
  if (docIcon && !genericIcons.includes(docIcon.toLowerCase())) {
    return renderIconSvg(resolveIconName(docIcon), 'folder-card-icon-svg');
  }

  // Try to infer from folder key
  const inferredName = folderIconInference[folderKey.toLowerCase()];
  if (inferredName) {
    return renderIconSvg(inferredName as IconName, 'folder-card-icon-svg');
  }

  // Default: folder icon
  return renderIconSvg('folder' as IconName, 'folder-card-icon-svg');
}

// ─── Normalize ALL CAPS titles from legacy CMS data ──────────────────
// When the old CSS used text-transform:uppercase, stored titles didn't matter.
// Now we display as-is, so normalize ALL CAPS → proper Title Case.
const SPECIAL_TITLE_MAP: Record<string, string> = {
  'ios': 'iOS', 'ipados': 'iPadOS', 'ios & ipados': 'iOS & iPadOS',
  'ios and ipados': 'iOS and iPadOS', 'macos': 'macOS', 'tvos': 'tvOS',
  'watchos': 'watchOS', 'api': 'API', 'api reference': 'API Reference',
  'api docs': 'API Docs', 'sdk': 'SDK', 'mdm': 'MDM', 'emm': 'EMM',
  'oem': 'OEM', 'sso': 'SSO',
};
const KNOWN_ACRONYMS = new Set(['api', 'sdk', 'mdm', 'emm', 'oem', 'sso', 'vpn', 'usb', 'nfc', 'ota', 'apk', 'adb', 'dep', 'abm', 'asm', 'byod', 'saml']);
function normalizeAllCapsTitle(title: string): string {
  const alpha = title.replace(/[^a-zA-Z]/g, '');
  if (alpha.length <= 1 || alpha !== alpha.toUpperCase()) return title;
  const lowerTrimmed = title.toLowerCase().trim();
  if (SPECIAL_TITLE_MAP[lowerTrimmed]) return SPECIAL_TITLE_MAP[lowerTrimmed];
  return title.toLowerCase().replace(/\b[a-z]+/g, word => {
    if (KNOWN_ACRONYMS.has(word)) return word.toUpperCase();
    if (word === 'ios') return 'iOS';
    if (word === 'ipados') return 'iPadOS';
    if (word === 'macos') return 'macOS';
    if (word === 'tvos') return 'tvOS';
    if (word === 'watchos') return 'watchOS';
    return word.charAt(0).toUpperCase() + word.slice(1);
  });
}

// ─── getStaticPaths — single data load, zero per-page API calls ──────

type DocEntry = (Awaited<ReturnType<typeof getCollection>>)[0];
type DocData = DocEntry['data'];

export async function getStaticPaths() {
  // ONE call to the local data store (populated by the CMS loader)
  const allDocs = await getCollection('docs');
  const [settings, cmsFolderSettings] = await Promise.all([
    getAllSettings(),
    getFolderSettings(),
  ]);

  // Precompute manual labels from sidebar settings
  const manualLabels = new Map<string, string>();
  const sideMenu = settings?.navigation?.sideMenu;
  if (sideMenu?.mode === 'manual' && sideMenu.items) {
    const collectManualLabels = (items: any[]) => {
      for (const item of items) {
        if (item.folder && item.label) {
          const slug = item.folder
            .replace(/^[a-z]{2}\//, '') // remove locale
            .replace(/^docs\//, '') // remove docs prefix
            .replace(/^\/+|\/+$/g, '')
            .toLowerCase();
          manualLabels.set(slug, item.label);
        }
        if (item.children) {
          collectManualLabels(item.children);
        }
      }
    };
    collectManualLabels(sideMenu.items);
  }

  // Precompute translation lookup (group by translation_key)
  const translationMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const key = entry.data.translation_key;
    if (key) {
      if (!translationMap.has(key)) translationMap.set(key, []);
      translationMap.get(key)!.push(entry);
    }
  }

  // Precompute path pattern lookup for translation fallback
  const pathPatternMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const pattern = getPathPattern(entry.data);
    if (pattern) {
      if (!pathPatternMap.has(pattern)) pathPatternMap.set(pattern, []);
      pathPatternMap.get(pattern)!.push(entry);
    }
  }

  const paths: Array<{
    params: { locale: string; slug: string };
    props: {
      entry: DocEntry | null;
      isIndex: boolean;
      locale: Locale;
      allDocs: typeof allDocs;
      translationMap: typeof translationMap;
      pathPatternMap: typeof pathPatternMap;
      virtual?: { title: string; path: string; collection: string };
    };
  }> = [];

  const resolveDocLocale = (doc: { locale?: string; path?: string }): Locale =>
    (doc.locale && locales.includes(doc.locale as Locale))
      ? (doc.locale as Locale)
      : extractLocaleFromPath(doc.path || '') || 'en';

  const validDocs = allDocs.filter((entry) => {
    const doc = entry.data;
    if (!isValidSlug(doc.slug) && !isValidSlug(doc.path)) return false;
    if (doc.type !== 'archive') return true;

    const folderPath = getIndexFolderPath(doc);
    if (!folderPath) return false;
    const docLocale = resolveDocLocale(doc);

    // API collection archives represent user-created folders in the CMS —
    // always generate their routes even if empty (entities may be added later).
    if (doc.collection === 'api') return true;

    // Archive pages with rendered content should always generate a route
    // even if they have no children (e.g. Platform overview with body text)
    if (entry.rendered?.html) return true;

    const hasChildren = allDocs.some((other) => {
      const d = other.data;
      if (!d.path || other.id === entry.id) return false;
      if (d.visible === false) return false;
      if (resolveDocLocale(d) !== docLocale) return false;
      if (isIndexFile(d)) return false;
      const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
      return docFolder === folderPath || docFolder.startsWith(folderPath + '/');
    });

    return hasChildren;
  });

  for (const entry of validDocs) {
    const doc = entry.data;
    const isIndex = isIndexFile(doc);

    const docLocale: Locale = resolveDocLocale(doc);

    let fullSlug: string;

    if (isValidSlug(doc.path)) {
      fullSlug = extractSlugFromPath(doc.path, isIndex);
    } else if (isValidSlug(doc.slug)) {
      fullSlug = doc.slug;
    } else {
      const collection = doc.collection || 'docs';
      fullSlug = `${collection}/${entry.id}`;
    }

    fullSlug = fullSlug.replace(/\/+/g, '/').replace(/^\/|\/$/g, '');

    // Allow top-level slugs (e.g., /en/device-management) if they are in the allowed collections
    const isTopLevelAllowed = fullSlug && !fullSlug.includes('/') && [
      'device-management',
      'app-distribution',
      'platform',
      'academy',
      'insights',
      'roadmap',
      'glossary',
      'answers',
      'product-updates',
      'about',
      'mdm',
      'api',
      'docs'
    ].includes(fullSlug);

    if (!fullSlug || (!fullSlug.includes('/') && !isTopLevelAllowed)) {
      continue;
    }

    paths.push({
      params: { locale: docLocale, slug: fullSlug },
      props: {
        entry,
        isIndex,
        locale: docLocale,
        allDocs,
        translationMap,
        pathPatternMap,
      },
    });
  }

  const indexFoldersByLocale = new Map<Locale, Set<string>>();
  const childFoldersByLocale = new Map<Locale, Set<string>>();
  const pathKeys = new Set(paths.map(p => `${p.params.locale}:${p.params.slug}`));

  for (const entry of allDocs) {
    const doc = entry.data;
    if (!doc.path) continue;
    const docLocale = resolveDocLocale(doc);
    if (isIndexFile(doc)) {
      const folderPath = getIndexFolderPath(doc);
      if (!folderPath) continue;
      if (!indexFoldersByLocale.has(docLocale)) indexFoldersByLocale.set(docLocale, new Set());
      indexFoldersByLocale.get(docLocale)!.add(folderPath);
      continue;
    }
    if (doc.visible === false) continue;
    let docFolder = doc.path.replace(/\/[^/]+\.mdx?$/, '');
    if (!childFoldersByLocale.has(docLocale)) childFoldersByLocale.set(docLocale, new Set());
    
    // Add the folder and all its parent folders up to the locale/docs root
    while (docFolder && docFolder.includes('/')) {
      childFoldersByLocale.get(docLocale)!.add(docFolder);
      const parts = docFolder.split('/');
      parts.pop();
      docFolder = parts.join('/');
      // Stop if we reach the base content folders
      if (docFolder === 'src/content' || docFolder === 'content' || docFolder.match(/^(src\/)?content\/[a-z]{2}(\/docs)?$/)) {
        break;
      }
    }
  }

  const toTitle = (value: string) =>
    value
      .split('-')
      .map(part => (part ? part[0].toUpperCase() + part.slice(1) : part))
      .join(' ');

  for (const [docLocale, folderPaths] of childFoldersByLocale.entries()) {
    const indexFolders = indexFoldersByLocale.get(docLocale) || new Set<string>();
    for (const folderPath of folderPaths) {
      if (indexFolders.has(folderPath)) continue;
      const folderSlug = extractSlugFromPath(`${folderPath}/index.md`, true);
      if (!folderSlug) continue;
      const key = `${docLocale}:${folderSlug}`;
      if (pathKeys.has(key)) continue;
      const segment = folderSlug.split('/').pop() || folderSlug;
      // Check CMS folder settings for a label override
      const cmsPathKey = `src/content/${docLocale}/docs/${folderSlug}`;
      const cmsFolderLabel = cmsFolderSettings?.[cmsPathKey]?.label || cmsFolderSettings?.[folderPath]?.label;
      const title = cmsFolderLabel || manualLabels.get(folderSlug) || toTitle(segment);
      const collection = folderSlug.split('/')[0] || 'docs';
      paths.push({
        params: { locale: docLocale, slug: folderSlug },
        props: {
          entry: null,
          isIndex: true,
          locale: docLocale,
          allDocs,
          translationMap,
          pathPatternMap,
          virtual: { title, path: folderPath, collection },
        },
      });
      pathKeys.add(key);
    }
  }

  if (paths.length > 0 && import.meta.env.DEV) {
    console.log(`[locale]/[...slug] Generated ${paths.length} paths. Sample:`, paths.slice(0, 3).map(p => `/${p.params.locale}/${p.params.slug}`));
  }

  return paths;
}

// ─── Page rendering — all data from props, zero API calls ────────────

const { entry, isIndex, locale, allDocs, translationMap, pathPatternMap, virtual } = Astro.props;
const fullDocument = (entry?.data || {
  title: virtual?.title || 'Untitled',
  description: virtual ? `Explore our comprehensive documentation for ${virtual.title}.` : undefined,
  collection: virtual?.collection || 'docs',
  locale,
  type: 'archive' as const,
  path: virtual?.path,
  slug: undefined,
  visible: true,
  item_name: virtual?.title,
  show_child_grid: true,
  draft: false,
}) as DocData;

// Normalize ALL CAPS titles from legacy CMS data on the page document
if (fullDocument.title) fullDocument.title = normalizeAllCapsTitle(fullDocument.title);
if (fullDocument.item_name && fullDocument.item_name !== 'null') fullDocument.item_name = normalizeAllCapsTitle(fullDocument.item_name);

if (!isValidLocale(locale)) {
  return Astro.redirect(`/${defaultLocale}/`, 301);
}

// Redirect to /en/roadmap/ if someone accesses /en/roadmap without trailing slash
if (Astro.url.pathname.endsWith('/roadmap')) {
  return Astro.redirect(`${Astro.url.pathname}/`, 301);
}

// Content is already in the data store — no API call needed
const content = entry?.rendered?.html || '';

// Fetch CMS folder settings for archive grid (label, icon, order overrides)
let cmsFolderSettings: FolderSettingsMap = {};
try {
  cmsFolderSettings = await getFolderSettings();
} catch { /* non-fatal */ }

// Apply CMS folder settings label to the page heading (final override after normalization)
if (isIndex && cmsFolderSettings && Object.keys(cmsFolderSettings).length > 0) {
  const pageFolderPath = getIndexFolderPath(fullDocument);
  if (pageFolderPath) {
    const pageSlug = pageFolderPath.replace(/^src\/content\/[a-z]{2}\/docs\//, '').replace(/^content\/[a-z]{2}\/docs\//, '');
    const pagePathVariants = [
      `src/content/${locale}/docs/${pageSlug}`,
      `content/${locale}/docs/${pageSlug}`,
      `${locale}/docs/${pageSlug}`,
      pageSlug,
    ];
    for (const variant of pagePathVariants) {
      if (cmsFolderSettings[variant]?.label) {
        fullDocument.title = cmsFolderSettings[variant].label;
        if (fullDocument.item_name && fullDocument.item_name !== 'null') {
          fullDocument.item_name = cmsFolderSettings[variant].label;
        }
        break;
      }
    }
  }
}

// For index/archive pages, find child documents from the local store
// The show_child_grid flag (default true) controls whether the grid renders
const showChildGrid = fullDocument.show_child_grid !== false;
let childDocuments: typeof allDocs = [];
let childFolders: Array<{ id: string; title: string; description: string; href: string; icon?: string; iconHtml: string; order: number; endpointCount: number }> = [];
const entryId = entry?.id;
if (isIndex && showChildGrid) {
  const folderPath = getIndexFolderPath(fullDocument);
  // Collect direct child endpoints (articles, non-index files)
  childDocuments = allDocs.filter((other) => {
    const d = other.data;
    if (!d.path || (entryId && other.id === entryId)) return false;
    if (d.visible === false) return false;
    if (d.locale !== locale) return false;
    if (isIndexFile(d)) return false;
    const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
    return docFolder === folderPath;
  }).sort((a, b) => {
    const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
    const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
    return orderA - orderB;
  });

  // Also collect direct child sub-folders (archive/index pages) for all archive pages
  const isApiCollection = fullDocument.collection === 'api' || fullDocument.schema_type === 'WebAPI';
  // Find archive pages that are direct children of this folder
  const directChildArchives = allDocs.filter((other) => {
    const d = other.data;
    if (!d.path || (entryId && other.id === entryId)) return false;
    if (d.visible === false) return false;
    if (d.locale !== locale) return false;
    if (!isIndexFile(d) && d.type !== 'archive') return false;
    // Check if this archive is a DIRECT child folder (one level deeper)
    const otherFolderPath = getIndexFolderPath(d);
    if (!otherFolderPath || !otherFolderPath.startsWith(folderPath + '/')) return false;
    // Ensure it's only one level deeper
    const relative = otherFolderPath.slice(folderPath.length + 1);
    return relative.length > 0 && !relative.includes('/');
  });

  // Deduplicate archives by folder path (prefer index.mdx over folder-named files)
  const archiveByFolder = new Map<string, typeof directChildArchives[0]>();
  for (const archive of directChildArchives) {
    const fp = getIndexFolderPath(archive.data);
    if (!fp) continue;
    const existing = archiveByFolder.get(fp);
    if (!existing) {
      archiveByFolder.set(fp, archive);
    } else {
      // Prefer the one with 'index' in filename
      const isIndex = archive.data.path?.match(/\/index\.mdx?$/);
      if (isIndex) archiveByFolder.set(fp, archive);
    }
  }
  const deduplicatedArchives = Array.from(archiveByFolder.values());

  // Collect folder paths that already have index/archive pages
  const archiveFolderPaths = new Set<string>();
  for (const archive of deduplicatedArchives) {
    const fp = getIndexFolderPath(archive.data);
    if (fp) archiveFolderPaths.add(fp);
  }

  // Also detect sub-folders from document paths that DON'T have index files
  // (e.g. app-distribution/distribute/ has docs but no index.mdx)
  const virtualFolders = new Map<string, { folderPath: string; folderKey: string }>();
  for (const other of allDocs) {
    const d = other.data;
    if (!d.path || d.visible === false || d.locale !== locale) continue;
    if (isIndexFile(d)) continue;
    const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
    // Check if this doc is inside a direct child sub-folder of the current page
    if (!docFolder.startsWith(folderPath + '/')) continue;
    const relative = docFolder.slice(folderPath.length + 1);
    const firstSegment = relative.split('/')[0];
    if (!firstSegment) continue;
    const childFolderPath = folderPath + '/' + firstSegment;
    // Skip if this folder already has an index/archive page
    if (archiveFolderPaths.has(childFolderPath)) continue;
    if (!virtualFolders.has(childFolderPath)) {
      virtualFolders.set(childFolderPath, { folderPath: childFolderPath, folderKey: firstSegment });
    }
  }

  // Count child docs per sub-folder (both real archives and virtual folders)
  for (const archive of deduplicatedArchives) {
    const archiveFolderPath = getIndexFolderPath(archive.data);
    if (!archiveFolderPath) continue;
    const childCount = allDocs.filter((other) => {
      const d = other.data;
      if (!d.path || d.visible === false || d.locale !== locale) return false;
      if (isIndexFile(d)) return false;
      const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
      return docFolder === archiveFolderPath || docFolder.startsWith(archiveFolderPath + '/');
    }).length;

    const docIcon = archive.data.sidebar_icon || archive.data.icon;
    childFolders.push({
      id: archive.id,
      title: normalizeAllCapsTitle(archive.data.item_name || archive.data.title || 'Untitled'),
      description: archive.data.description || '',
      href: getDocUrl({ ...archive.data, id: archive.id }, locale),
      icon: docIcon,
      iconHtml: resolveFolderIcon(archiveFolderPath, docIcon),
      order: archive.data.sidebar_position ?? archive.data.order_num ?? archive.data.weight ?? 999,
      endpointCount: childCount,
    });
  }

  // Add virtual folder cards (sub-folders with docs but no index file)
  const toTitle = (value: string) =>
    value.split('-').map(part => (part ? part[0].toUpperCase() + part.slice(1) : part)).join(' ');

  for (const [vfPath, { folderKey }] of virtualFolders) {
    const childCount = allDocs.filter((other) => {
      const d = other.data;
      if (!d.path || d.visible === false || d.locale !== locale) return false;
      if (isIndexFile(d)) return false;
      const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
      return docFolder === vfPath || docFolder.startsWith(vfPath + '/');
    }).length;

    // Build href from the virtual folder slug
    const vfSlug = extractSlugFromPath(vfPath + '/index.md', true);
    const vfHref = `/${locale}/${vfSlug}/`;

    childFolders.push({
      id: `virtual-${folderKey}`,
      title: toTitle(folderKey),
      description: '',
      href: vfHref,
      icon: undefined,
      iconHtml: resolveFolderIcon(vfPath),
      order: 999,
      endpointCount: childCount,
    });
  }

  // Apply CMS folder settings overrides (label, icon, order)
  // Folder settings keys use paths like: src/content/en/docs/device-management/android
  if (cmsFolderSettings && Object.keys(cmsFolderSettings).length > 0) {
    for (const folder of childFolders) {
      // Determine the folder's CMS path from its href
      // href is like /en/device-management/android → src/content/en/docs/device-management/android
      const hrefSlug = folder.href.replace(/^\/[a-z]{2}\//, '').replace(/\/$/, '');
      const pathVariants = [
        `src/content/${locale}/docs/${hrefSlug}`,
        `content/${locale}/docs/${hrefSlug}`,
        `${locale}/docs/${hrefSlug}`,
        hrefSlug,
      ];
      let settings = null;
      for (const variant of pathVariants) {
        if (cmsFolderSettings[variant]) {
          settings = cmsFolderSettings[variant];
          break;
        }
      }
      if (settings) {
        if (settings.label) folder.title = settings.label;
        if (settings.icon) {
          folder.icon = settings.icon;
          // Re-resolve icon HTML with the CMS-provided icon
          const archiveFolderPath = pathVariants[0]; // Use the full src/content path
          folder.iconHtml = resolveFolderIcon(archiveFolderPath, settings.icon);
        } else {
          // CMS has a setting for this folder but icon is empty —
          // use default folder icon, don't let inference override
          folder.icon = 'folder';
          folder.iconHtml = renderIconSvg('folder' as IconName, 'folder-card-icon-svg');
        }
        if (settings.order != null) folder.order = settings.order;
      }
    }
  }

  childFolders.sort((a, b) => a.order - b.order);
}

// Find available translations — from precomputed maps, zero API calls
let availableTranslations: Locale[] = [locale];
const translationSlugs: Partial<Record<Locale, string>> = {};

// 1. Check translation_key
if (fullDocument.translation_key) {
  const translations = translationMap.get(fullDocument.translation_key) || [];
  for (const t of translations) {
    const tLocale = t.data.locale as Locale;
    if (tLocale !== locale && locales.includes(tLocale) && !availableTranslations.includes(tLocale)) {
      availableTranslations.push(tLocale);
      translationSlugs[tLocale] = getDocSlug({ ...t.data, id: t.id });
    }
  }
}

// 2. Fallback: check path pattern match
if (availableTranslations.length <= 1) {
  const currentPattern = getPathPattern(fullDocument);
  if (currentPattern) {
    const matches = pathPatternMap.get(currentPattern) || [];
    for (const m of matches) {
      const mLocale = m.data.locale as Locale;
      if (mLocale !== locale && locales.includes(mLocale) && !availableTranslations.includes(mLocale)) {
        availableTranslations.push(mLocale);
        translationSlugs[mLocale] = getDocSlug({ ...m.data, id: m.id });
      }
    }
  }
}

// Extract section and category
const section = Array.isArray(fullDocument.section) ? fullDocument.section[0] : fullDocument.section;
const category = Array.isArray(fullDocument.category) ? fullDocument.category[0] : fullDocument.category;

// Build JSON-LD for API reference pages (WebAPI + TechArticle schema)
const isApiPage = fullDocument.collection === 'api' || fullDocument.schema_type === 'WebAPI';
let apiJsonLd: Record<string, any> | null = null;
if (isApiPage) {
  const siteUrl = Astro.site?.href || Astro.url.origin;
  const pageUrl = new URL(Astro.url.pathname, siteUrl).href;
  const headline = fullDocument.headline || fullDocument.title;

  apiJsonLd = {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": fullDocument.title,
    "headline": headline,
    "description": fullDocument.description || '',
    "url": pageUrl,
    "datePublished": fullDocument.pub_date || fullDocument.created_at,
    "dateModified": fullDocument.updated_date || fullDocument.updated_at,
    "articleSection": "API Reference",
    "proficiencyLevel": "Advanced",
    "about": {
      "@type": "WebAPI",
      "name": headline,
      "description": fullDocument.description || '',
      "url": pageUrl,
      "documentation": pageUrl,
    },
    "isPartOf": {
      "@type": "APIReference",
      "name": "Applivery API Reference",
      "url": `${siteUrl}/${locale}/api/`,
    },
    "inLanguage": locale,
  };
}

// Process markdown content
let processedContent = content ? processMarkdown(content) : '';

// Resolve <ChildGrid /> placeholders from local data (no API calls)
if (processedContent.includes('data-child-grid="true"')) {
  const gridPlaceholderRegex = /<div data-child-grid="true"(?:\s+data-path="([^"]*)")?(?:\s+data-columns="(\d+)")?(?:\s+data-filters="(true|false)")?><\/div>/g;

  const docFolderPath = fullDocument.path
    ? fullDocument.path.replace(/\/[^/]+\.mdx?$/, '')
    : '';

  const placeholders: Array<{ match: string; path: string; columns: number; filters: boolean }> = [];
  let m;
  while ((m = gridPlaceholderRegex.exec(processedContent)) !== null) {
    const customPath = m[1] || '';
    const columns = parseInt(m[2] || '3', 10) as 2 | 3 | 4;
    const filters = m[3] !== 'false';
    const resolvedFolder = customPath
      ? `content/${locale}/docs/${customPath}`
      : docFolderPath;
    placeholders.push({ match: m[0], path: resolvedFolder, columns, filters });
  }

  if (placeholders.length > 0) {
    // Filter from local store — no API call
    const collectionDocs = allDocs.filter(d =>
      d.data.collection === (fullDocument.collection || 'docs') &&
      d.data.visible !== false &&
      d.data.locale === locale
    );

    for (const ph of placeholders) {
      const gridDocs = collectionDocs.filter((other) => {
        const d = other.data;
        if (!d.path || (entryId && other.id === entryId)) return false;
        if (d.type === 'archive') return false;
        if (isIndexFile(d)) return false;
        const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
        return docFolder === ph.path;
      }).sort((a, b) => {
        const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
        const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
        return orderA - orderB;
      });

      if (gridDocs.length > 0) {
        const colClass = `cols-${ph.columns}`;
        const cards = gridDocs.map((d) => {
          const href = getDocUrl({ ...d.data, id: d.id }, locale);
          const desc = d.data.description ? `<p class="child-grid-card-desc">${d.data.description}</p>` : '';
          return `<a href="${href}" class="child-grid-card">
            <span class="child-grid-card-title">${d.data.title}</span>
            ${desc}
          </a>`;
        }).join('');

        const gridHtml = `<div class="child-grid ${colClass}">${cards}</div>`;
        processedContent = processedContent.replace(ph.match, gridHtml);
      } else {
        processedContent = processedContent.replace(ph.match, '');
      }
    }
  }
}

// Extract headings for TOC
// For API pages, extract from processed HTML (since API components generate headings)
// For regular pages, extract from raw markdown
let headings: Array<{ depth: number; slug: string; text: string }> = [];
if (isApiPage && processedContent) {
  // Parse headings from rendered HTML: <h2 id="...">...</h2>
  const htmlHeadingRegex = /<h([23])\s+id="([^"]*)"[^>]*>(.*?)<\/h[23]>/gi;
  let hm;
  while ((hm = htmlHeadingRegex.exec(processedContent)) !== null) {
    const text = hm[3].replace(/<[^>]+>/g, '').trim();
    if (text) {
      headings.push({ depth: parseInt(hm[1]), slug: hm[2], text });
    }
  }
  // If no id-based headings, fall back to section titles from API components
  if (headings.length === 0) {
    const sectionTitleRegex = /<h([23])[^>]*>(.*?)<\/h[23]>/gi;
    while ((hm = sectionTitleRegex.exec(processedContent)) !== null) {
      const text = hm[2].replace(/<[^>]+>/g, '').trim();
      const slug = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
      if (text) {
        headings.push({ depth: parseInt(hm[1]), slug, text });
      }
    }
  }
} else {
  headings = content ? extractHeadings(content) : [];
}
---

<DocLayout
  title={fullDocument.title}
  breadcrumbTitle={(fullDocument.item_name && fullDocument.item_name !== 'null') ? fullDocument.item_name : (section || fullDocument.title)}
  icon={fullDocument.icon}
  sidebarIcon={fullDocument.sidebar_icon}
  description={fullDocument.description}
  ogTitle={fullDocument.og_title || fullDocument.seo_title}
  ogDescription={fullDocument.og_description || fullDocument.description}
  ogImage={resolveMediaUrl(fullDocument.og_image || fullDocument.hero_image)}
  canonical={fullDocument.canonical}
  noindex={fullDocument.noindex}
  collection={fullDocument.collection}
  section={section}
  category={category}
  keywords={fullDocument.keywords}
  audience={fullDocument.audience}
  difficulty={fullDocument.difficulty}
  platform={fullDocument.platform}
  readingTime={isIndex ? undefined : fullDocument.reading_time}
  tldr={fullDocument.tldr}
  keyTakeaways={fullDocument.key_takeaways}
  author={fullDocument.author}
  authorUrl={fullDocument.author_url}
  datePublished={(fullDocument.pub_date || fullDocument.date)?.toISOString()}
  dateModified={fullDocument.updated_date?.toISOString()}
  heroImage={resolveMediaUrl(fullDocument.hero_image)}
  imageAlt={fullDocument.image_alt}
  headings={headings}
  currentPath={Astro.url.pathname}
  sourcePath={fullDocument.path}
  locale={locale}
  availableTranslations={availableTranslations}
  translationSlugs={translationSlugs}
>
  {/* API Reference JSON-LD for SEO / LLM indexing */}
  {apiJsonLd && (
    <script type="application/ld+json" set:html={JSON.stringify(apiJsonLd)} />
  )}

  {/* Render document content */}
  {processedContent ? (
    <Fragment set:html={processedContent} />
  ) : !isIndex && (
    <p class="text-[var(--color-text-muted)]">No content available</p>
  )}

  {/* For API archive pages, render sub-folder cards + endpoint cards */}
  {isIndex && isApiPage && showChildGrid && (childFolders.length > 0 || childDocuments.length > 0) && (
    <div class="api-archive-grid">
      {/* Sub-folder cards */}
      {childFolders.length > 0 && (
        <div class="api-folders-section">
          {childFolders.map(folder => (
            <a href={folder.href} class="api-folder-card">
              <div class="api-folder-card-icon">
                <Fragment set:html={folder.iconHtml} />
              </div>
              <div class="api-folder-card-body">
                <span class="api-folder-card-title">{folder.title}</span>
                <span class="api-folder-card-count">{folder.endpointCount} endpoint{folder.endpointCount !== 1 ? 's' : ''}</span>
              </div>
              <svg class="api-folder-card-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
            </a>
          ))}
        </div>
      )}

      {/* Endpoint cards */}
      {childDocuments.length > 0 && (
        <div class="api-endpoints-section">
          {childDocuments.map(d => {
            const href = getDocUrl({ ...d.data, id: d.id }, locale);
            const headline = d.data.headline || '';
            const headlineParts = headline.match(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+(.+)$/i);
            const method = headlineParts ? headlineParts[1].toUpperCase() : '';
            const endpointPath = headlineParts ? headlineParts[2] : '';
            const rawDesc = d.data.description || '';
            const cleanDesc = rawDesc.replace(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+\S+\s*[—–-]\s*/i, '');
            return (
              <a href={href} class="api-endpoint-card">
                <div class="api-endpoint-card-header">
                  {method && <span class={`api-method-badge method-${method.toLowerCase()}`}>{method}</span>}
                  <span class="api-endpoint-card-title">{d.data.title}</span>
                </div>
                {endpointPath && <code class="api-endpoint-card-path">{endpointPath}</code>}
                {cleanDesc && <p class="api-endpoint-card-desc">{cleanDesc}</p>}
              </a>
            );
          })}
        </div>
      )}
    </div>
  )}

  {/* For non-API index/archive pages, show child folders + standard card grid */}
  {isIndex && !isApiPage && showChildGrid && (childFolders.length > 0 || childDocuments.length > 0) && (
    <div class="archive-content-grid">
      {/* Child folder cards */}
      {childFolders.length > 0 && (
        <div class="archive-folders-section">
          {childFolders.map(folder => (
            <a href={folder.href} class="archive-folder-card">
              <div class="archive-folder-card-icon">
                <Fragment set:html={folder.iconHtml} />
              </div>
              <div class="archive-folder-card-body">
                <span class="archive-folder-card-title">{folder.title}</span>
                {folder.description && <p class="archive-folder-card-desc">{folder.description}</p>}
                <span class="archive-folder-card-count">{folder.endpointCount} article{folder.endpointCount !== 1 ? 's' : ''}</span>
              </div>
              <svg class="archive-folder-card-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
            </a>
          ))}
        </div>
      )}

      {/* Direct child article cards */}
      {childDocuments.length > 0 && (
        <ArchiveGrid
          items={childDocuments.map(d => {
            return ({
              id: d.id,
              title: d.data.title,
              description: d.data.description,
              og_title: d.data.og_title,
              og_description: d.data.og_description,
              href: getDocUrl({ ...d.data, id: d.id }, locale),
              section: d.data.section,
              platform: d.data.platform,
              hero_image: resolveMediaUrl(d.data.hero_image),
              og_image: resolveMediaUrl(d.data.og_image),
              image_alt: d.data.image_alt,
              reading_time: d.data.reading_time,
              featured: d.data.featured,
              pub_date: d.data.pub_date?.toISOString(),
            });
          })}
          pageTitle={fullDocument.title}
          pageDescription={fullDocument.description}
          pageUrl={Astro.url.href}
          enableFilters={true}
          columns={3}
          showImages={true}
        />
      )}
    </div>
  )}

  {/* Empty state for index with no children and no content */}
  {isIndex && childDocuments.length === 0 && childFolders.length === 0 && !processedContent && (
    <div class="archive-empty">
      <p class="text-[var(--color-text-muted)]">No articles in this section yet.</p>
    </div>
  )}
</DocLayout>

<style>
  :global(.archive-grid) {
    margin-top: 1.5rem;
  }

  .archive-empty {
    margin-top: 2rem;
    text-align: center;
    padding: 2rem;
  }

  /* ── Non-API Archive Content Grid ── */
  .archive-content-grid {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .archive-folders-section {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
  }

  @media (max-width: 640px) {
    .archive-folders-section {
      grid-template-columns: 1fr;
    }
  }

  .archive-folder-card {
    display: flex;
    align-items: center;
    gap: 0.875rem;
    padding: 1rem 1.125rem;
    border: 1px solid var(--color-border);
    border-radius: 0.875rem;
    text-decoration: none;
    color: inherit;
    background: var(--color-surface);
    transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    position: relative;
  }

  .archive-folder-card:hover {
    border-color: var(--color-primary-50);
    box-shadow: 0 12px 30px -18px rgba(2, 6, 23, 0.35);
    transform: translateY(-2px);
    text-decoration: none;
  }

  :global(.dark) .archive-folder-card:hover {
    border-color: var(--color-accent-10);
    box-shadow: 0 12px 30px -18px rgba(0, 0, 0, 0.65);
  }

  .archive-folder-card-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2.5rem;
    height: 2.5rem;
    flex-shrink: 0;
    border-radius: 0.625rem;
    background: var(--color-primary-10);
    color: var(--color-primary);
  }

  :global(.dark) .archive-folder-card-icon {
    background: var(--color-accent-10);
    color: var(--color-accent-light);
  }

  .archive-folder-card-icon svg,
  .archive-folder-card-icon :global(.folder-card-icon-svg) {
    width: 1.25rem;
    height: 1.25rem;
  }

  .archive-folder-card-body {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    min-width: 0;
    flex: 1;
  }

  .archive-folder-card-title {
    font-weight: 600;
    font-size: 0.9375rem;
    color: var(--color-text-primary);
    line-height: 1.3;
  }

  .archive-folder-card:hover .archive-folder-card-title {
    color: var(--color-primary);
  }

  :global(.dark) .archive-folder-card:hover .archive-folder-card-title {
    color: var(--color-accent-light);
  }

  .archive-folder-card-desc {
    font-size: 0.8125rem;
    color: var(--color-text-secondary);
    line-height: 1.4;
    margin: 0;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .archive-folder-card-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    line-height: 1.3;
  }

  .archive-folder-card-arrow {
    width: 1rem;
    height: 1rem;
    color: var(--color-text-muted);
    flex-shrink: 0;
    opacity: 0;
    transform: translateX(-4px);
    transition: all 0.2s ease;
  }

  .archive-folder-card:hover .archive-folder-card-arrow {
    opacity: 0.7;
    transform: translateX(0);
    color: var(--color-primary);
  }

  :global(.dark) .archive-folder-card:hover .archive-folder-card-arrow {
    color: var(--color-accent-light);
  }

  /* ── API Archive Grid ── */
  .api-archive-grid {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* API Folder Cards - Grid */
  .api-folders-section {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
  }

  @media (max-width: 640px) {
    .api-folders-section {
      grid-template-columns: 1fr;
    }
  }

  .api-folder-card {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem 1.125rem;
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    text-decoration: none;
    color: inherit;
    background: var(--color-surface);
    transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    position: relative;
  }

  .api-folder-card:hover {
    border-color: var(--color-primary-50);
    box-shadow: 0 8px 24px -12px rgba(2, 6, 23, 0.2);
    transform: translateY(-1px);
    text-decoration: none;
  }

  :global(.dark) .api-folder-card:hover {
    border-color: var(--color-accent-10);
    box-shadow: 0 8px 24px -12px rgba(0, 0, 0, 0.5);
  }

  .api-folder-card-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2.25rem;
    height: 2.25rem;
    flex-shrink: 0;
    border-radius: 0.5rem;
    background: var(--color-primary-10);
    color: var(--color-primary);
  }

  :global(.dark) .api-folder-card-icon {
    background: var(--color-accent-10);
    color: var(--color-accent-light);
  }

  .api-folder-card-icon svg,
  .api-folder-card-icon :global(.folder-card-icon-svg) {
    width: 1.25rem;
    height: 1.25rem;
  }

  .api-folder-card-body {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
    min-width: 0;
    flex: 1;
  }

  .api-folder-card-title {
    font-weight: 600;
    font-size: 0.9375rem;
    color: var(--color-text-primary);
    line-height: 1.3;
  }

  .api-folder-card:hover .api-folder-card-title {
    color: var(--color-primary);
  }

  :global(.dark) .api-folder-card:hover .api-folder-card-title {
    color: var(--color-accent-light);
  }

  .api-folder-card-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    line-height: 1.3;
  }

  .api-folder-card-arrow {
    width: 1rem;
    height: 1rem;
    color: var(--color-text-muted);
    flex-shrink: 0;
    opacity: 0;
    transform: translateX(-4px);
    transition: all 0.2s ease;
  }

  .api-folder-card:hover .api-folder-card-arrow {
    opacity: 0.7;
    transform: translateX(0);
    color: var(--color-primary);
  }

  :global(.dark) .api-folder-card:hover .api-folder-card-arrow {
    color: var(--color-accent-light);
  }

  /* API Endpoint Cards */
  .api-endpoints-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .api-endpoint-card {
    display: block;
    padding: 0.875rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.625rem;
    text-decoration: none;
    color: inherit;
    background: var(--color-surface);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .api-endpoint-card:hover {
    border-color: var(--color-primary-50);
    box-shadow: 0 4px 16px -8px rgba(2, 6, 23, 0.15);
    text-decoration: none;
  }

  :global(.dark) .api-endpoint-card:hover {
    border-color: var(--color-accent-10);
    box-shadow: 0 4px 16px -8px rgba(0, 0, 0, 0.4);
  }

  .api-endpoint-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .api-endpoint-card-title {
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--color-text-primary);
  }

  .api-endpoint-card:hover .api-endpoint-card-title {
    color: var(--color-primary);
  }

  :global(.dark) .api-endpoint-card:hover .api-endpoint-card-title {
    color: var(--color-accent-light);
  }

  .api-endpoint-card-path {
    display: block;
    margin-top: 0.25rem;
    font-size: 0.75rem;
    font-family: var(--font-code);
    color: var(--color-text-tertiary);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .api-endpoint-card-desc {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    margin: 0.375rem 0 0;
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
