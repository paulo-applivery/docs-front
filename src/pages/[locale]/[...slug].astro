---
/**
 * Dynamic documentation page route with locale support
 * URL: docs.applivery.com/{locale}/{product}/{path}
 *
 * Phase 0 rewrite: Uses getCollection('docs') from Content Layer.
 * Zero network calls during rendering — all data is local.
 */

import { getCollection } from 'astro:content';
import DocLayout from '../../layouts/DocLayout.astro';
import ArchiveGrid from '../../components/ArchiveGrid.astro';
import { resolveMediaUrl, getAllSettings } from '../../lib/cms';
import { processMarkdown } from '../../lib/markdown';
import {
  locales,
  isValidLocale,
  type Locale
} from '../../lib/i18n';
import {
  getIndexFolderPath,
  isIndexFile,
  extractSlugFromPath,
  extractLocaleFromPath,
  getPathPattern,
  getDocSlug,
  getDocUrl,
  extractHeadings,
  isValidSlug,
} from '../../lib/doc-helpers';

// ─── getStaticPaths — single data load, zero per-page API calls ──────

type DocEntry = (Awaited<ReturnType<typeof getCollection>>)[0];
type DocData = DocEntry['data'];

export async function getStaticPaths() {
  // ONE call to the local data store (populated by the CMS loader)
  const allDocs = await getCollection('docs');
  const settings = await getAllSettings();

  // Precompute manual labels from sidebar settings
  const manualLabels = new Map<string, string>();
  const sideMenu = settings?.navigation?.sideMenu;
  if (sideMenu?.mode === 'manual' && sideMenu.items) {
    const collectManualLabels = (items: any[]) => {
      for (const item of items) {
        if (item.folder && item.label) {
          const slug = item.folder
            .replace(/^[a-z]{2}\//, '') // remove locale
            .replace(/^docs\//, '') // remove docs prefix
            .replace(/^\/+|\/+$/g, '')
            .toLowerCase();
          manualLabels.set(slug, item.label);
        }
        if (item.children) {
          collectManualLabels(item.children);
        }
      }
    };
    collectManualLabels(sideMenu.items);
  }

  // Precompute translation lookup (group by translation_key)
  const translationMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const key = entry.data.translation_key;
    if (key) {
      if (!translationMap.has(key)) translationMap.set(key, []);
      translationMap.get(key)!.push(entry);
    }
  }

  // Precompute path pattern lookup for translation fallback
  const pathPatternMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const pattern = getPathPattern(entry.data);
    if (pattern) {
      if (!pathPatternMap.has(pattern)) pathPatternMap.set(pattern, []);
      pathPatternMap.get(pattern)!.push(entry);
    }
  }

  const paths: Array<{
    params: { locale: string; slug: string };
    props: {
      entry: DocEntry | null;
      isIndex: boolean;
      locale: Locale;
      allDocs: typeof allDocs;
      translationMap: typeof translationMap;
      pathPatternMap: typeof pathPatternMap;
      virtual?: { title: string; path: string; collection: string };
    };
  }> = [];

  const resolveDocLocale = (doc: { locale?: string; path?: string }): Locale =>
    (doc.locale && locales.includes(doc.locale as Locale))
      ? (doc.locale as Locale)
      : extractLocaleFromPath(doc.path || '') || 'en';

  const validDocs = allDocs.filter((entry) => {
    const doc = entry.data;
    if (!isValidSlug(doc.slug) && !isValidSlug(doc.path)) return false;
    if (doc.type !== 'archive') return true;

    const folderPath = getIndexFolderPath(doc);
    if (!folderPath) return false;
    const docLocale = resolveDocLocale(doc);

    // API collection archives represent user-created folders in the CMS —
    // always generate their routes even if empty (entities may be added later).
    if (doc.collection === 'api') return true;

    const hasChildren = allDocs.some((other) => {
      const d = other.data;
      if (!d.path || other.id === entry.id) return false;
      if (d.visible === false) return false;
      if (resolveDocLocale(d) !== docLocale) return false;
      if (isIndexFile(d)) return false;
      const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
      return docFolder === folderPath || docFolder.startsWith(folderPath + '/');
    });

    return hasChildren;
  });

  for (const entry of validDocs) {
    const doc = entry.data;
    const isIndex = isIndexFile(doc);

    const docLocale: Locale = resolveDocLocale(doc);

    let fullSlug: string;

    if (isValidSlug(doc.path)) {
      fullSlug = extractSlugFromPath(doc.path, isIndex);
    } else if (isValidSlug(doc.slug)) {
      fullSlug = doc.slug;
    } else {
      const collection = doc.collection || 'docs';
      fullSlug = `${collection}/${entry.id}`;
    }

    fullSlug = fullSlug.replace(/\/+/g, '/').replace(/^\/|\/$/g, '');

    // Allow top-level slugs (e.g., /en/device-management) if they are in the allowed collections
    const isTopLevelAllowed = fullSlug && !fullSlug.includes('/') && [
      'device-management',
      'app-distribution',
      'platform',
      'academy',
      'insights',
      'roadmap',
      'glossary',
      'answers',
      'product-updates',
      'about',
      'mdm',
      'api',
      'docs'
    ].includes(fullSlug);

    if (!fullSlug || (!fullSlug.includes('/') && !isTopLevelAllowed)) {
      continue;
    }

    paths.push({
      params: { locale: docLocale, slug: fullSlug },
      props: {
        entry,
        isIndex,
        locale: docLocale,
        allDocs,
        translationMap,
        pathPatternMap,
      },
    });
  }

  const indexFoldersByLocale = new Map<Locale, Set<string>>();
  const childFoldersByLocale = new Map<Locale, Set<string>>();
  const pathKeys = new Set(paths.map(p => `${p.params.locale}:${p.params.slug}`));

  for (const entry of allDocs) {
    const doc = entry.data;
    if (!doc.path) continue;
    const docLocale = resolveDocLocale(doc);
    if (isIndexFile(doc)) {
      const folderPath = getIndexFolderPath(doc);
      if (!folderPath) continue;
      if (!indexFoldersByLocale.has(docLocale)) indexFoldersByLocale.set(docLocale, new Set());
      indexFoldersByLocale.get(docLocale)!.add(folderPath);
      continue;
    }
    if (doc.visible === false) continue;
    let docFolder = doc.path.replace(/\/[^/]+\.mdx?$/, '');
    if (!childFoldersByLocale.has(docLocale)) childFoldersByLocale.set(docLocale, new Set());
    
    // Add the folder and all its parent folders up to the locale/docs root
    while (docFolder && docFolder.includes('/')) {
      childFoldersByLocale.get(docLocale)!.add(docFolder);
      const parts = docFolder.split('/');
      parts.pop();
      docFolder = parts.join('/');
      // Stop if we reach the base content folders
      if (docFolder === 'src/content' || docFolder === 'content' || docFolder.match(/^(src\/)?content\/[a-z]{2}(\/docs)?$/)) {
        break;
      }
    }
  }

  const toTitle = (value: string) =>
    value
      .split('-')
      .map(part => (part ? part[0].toUpperCase() + part.slice(1) : part))
      .join(' ');

  for (const [docLocale, folderPaths] of childFoldersByLocale.entries()) {
    const indexFolders = indexFoldersByLocale.get(docLocale) || new Set<string>();
    for (const folderPath of folderPaths) {
      if (indexFolders.has(folderPath)) continue;
      const folderSlug = extractSlugFromPath(`${folderPath}/index.md`, true);
      if (!folderSlug) continue;
      const key = `${docLocale}:${folderSlug}`;
      if (pathKeys.has(key)) continue;
      const segment = folderSlug.split('/').pop() || folderSlug;
      const title = manualLabels.get(folderSlug) || toTitle(segment);
      const collection = folderSlug.split('/')[0] || 'docs';
      paths.push({
        params: { locale: docLocale, slug: folderSlug },
        props: {
          entry: null,
          isIndex: true,
          locale: docLocale,
          allDocs,
          translationMap,
          pathPatternMap,
          virtual: { title, path: folderPath, collection },
        },
      });
      pathKeys.add(key);
    }
  }

  if (paths.length > 0 && import.meta.env.DEV) {
    console.log(`[locale]/[...slug] Generated ${paths.length} paths. Sample:`, paths.slice(0, 3).map(p => `/${p.params.locale}/${p.params.slug}`));
  }

  return paths;
}

// ─── Page rendering — all data from props, zero API calls ────────────

const { entry, isIndex, locale, allDocs, translationMap, pathPatternMap, virtual } = Astro.props;
const fullDocument = (entry?.data || {
  title: virtual?.title || 'Untitled',
  description: virtual ? `Explore our comprehensive documentation for ${virtual.title}.` : undefined,
  collection: virtual?.collection || 'docs',
  locale,
  type: 'archive' as const,
  path: virtual?.path,
  slug: undefined,
  visible: true,
  item_name: virtual?.title,
  show_child_grid: true,
  draft: false,
}) as DocData;

if (!isValidLocale(locale)) {
  return Astro.redirect(`/${defaultLocale}/`, 301);
}

// Redirect to /en/roadmap/ if someone accesses /en/roadmap without trailing slash
if (Astro.url.pathname.endsWith('/roadmap')) {
  return Astro.redirect(`${Astro.url.pathname}/`, 301);
}

// Content is already in the data store — no API call needed
const content = entry?.rendered?.html || '';

// For index/archive pages, find child documents from the local store
// The show_child_grid flag (default true) controls whether the grid renders
const showChildGrid = fullDocument.show_child_grid !== false;
let childDocuments: typeof allDocs = [];
let childFolders: Array<{ id: string; title: string; description: string; href: string; icon?: string; order: number; endpointCount: number }> = [];
const entryId = entry?.id;
if (isIndex && showChildGrid) {
  const folderPath = getIndexFolderPath(fullDocument);
  // Collect direct child endpoints (articles, non-index files)
  childDocuments = allDocs.filter((other) => {
    const d = other.data;
    if (!d.path || (entryId && other.id === entryId)) return false;
    if (d.visible === false) return false;
    if (d.locale !== locale) return false;
    if (isIndexFile(d)) return false;
    const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
    return docFolder === folderPath;
  }).sort((a, b) => {
    const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
    const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
    return orderA - orderB;
  });

  // For API pages, also collect direct child sub-folders (archive/index pages)
  const isApiCollection = fullDocument.collection === 'api' || fullDocument.schema_type === 'WebAPI';
  if (isApiCollection) {
    // Find archive pages that are direct children of this folder
    const directChildArchives = allDocs.filter((other) => {
      const d = other.data;
      if (!d.path || (entryId && other.id === entryId)) return false;
      if (d.visible === false) return false;
      if (d.locale !== locale) return false;
      if (!isIndexFile(d) && d.type !== 'archive') return false;
      // Check if this archive is a DIRECT child folder (one level deeper)
      const otherFolderPath = getIndexFolderPath(d);
      if (!otherFolderPath || !otherFolderPath.startsWith(folderPath + '/')) return false;
      // Ensure it's only one level deeper
      const relative = otherFolderPath.slice(folderPath.length + 1);
      return relative.length > 0 && !relative.includes('/');
    });

    // Count endpoints per sub-folder
    for (const archive of directChildArchives) {
      const archiveFolderPath = getIndexFolderPath(archive.data);
      if (!archiveFolderPath) continue;
      const endpointCount = allDocs.filter((other) => {
        const d = other.data;
        if (!d.path || d.visible === false || d.locale !== locale) return false;
        if (isIndexFile(d)) return false;
        const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
        return docFolder === archiveFolderPath || docFolder.startsWith(archiveFolderPath + '/');
      }).length;

      childFolders.push({
        id: archive.id,
        title: archive.data.item_name || archive.data.title || 'Untitled',
        description: archive.data.description || '',
        href: getDocUrl({ ...archive.data, id: archive.id }, locale),
        icon: archive.data.sidebar_icon || archive.data.icon,
        order: archive.data.sidebar_position ?? archive.data.order_num ?? archive.data.weight ?? 999,
        endpointCount,
      });
    }

    childFolders.sort((a, b) => a.order - b.order);
  }
}

// Find available translations — from precomputed maps, zero API calls
let availableTranslations: Locale[] = [locale];
const translationSlugs: Partial<Record<Locale, string>> = {};

// 1. Check translation_key
if (fullDocument.translation_key) {
  const translations = translationMap.get(fullDocument.translation_key) || [];
  for (const t of translations) {
    const tLocale = t.data.locale as Locale;
    if (tLocale !== locale && locales.includes(tLocale) && !availableTranslations.includes(tLocale)) {
      availableTranslations.push(tLocale);
      translationSlugs[tLocale] = getDocSlug({ ...t.data, id: t.id });
    }
  }
}

// 2. Fallback: check path pattern match
if (availableTranslations.length <= 1) {
  const currentPattern = getPathPattern(fullDocument);
  if (currentPattern) {
    const matches = pathPatternMap.get(currentPattern) || [];
    for (const m of matches) {
      const mLocale = m.data.locale as Locale;
      if (mLocale !== locale && locales.includes(mLocale) && !availableTranslations.includes(mLocale)) {
        availableTranslations.push(mLocale);
        translationSlugs[mLocale] = getDocSlug({ ...m.data, id: m.id });
      }
    }
  }
}

// Extract section and category
const section = Array.isArray(fullDocument.section) ? fullDocument.section[0] : fullDocument.section;
const category = Array.isArray(fullDocument.category) ? fullDocument.category[0] : fullDocument.category;

// Build JSON-LD for API reference pages (WebAPI + TechArticle schema)
const isApiPage = fullDocument.collection === 'api' || fullDocument.schema_type === 'WebAPI';
let apiJsonLd: Record<string, any> | null = null;
if (isApiPage) {
  const siteUrl = Astro.site?.href || Astro.url.origin;
  const pageUrl = new URL(Astro.url.pathname, siteUrl).href;
  const headline = fullDocument.headline || fullDocument.title;

  apiJsonLd = {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": fullDocument.title,
    "headline": headline,
    "description": fullDocument.description || '',
    "url": pageUrl,
    "datePublished": fullDocument.pub_date || fullDocument.created_at,
    "dateModified": fullDocument.updated_date || fullDocument.updated_at,
    "articleSection": "API Reference",
    "proficiencyLevel": "Advanced",
    "about": {
      "@type": "WebAPI",
      "name": headline,
      "description": fullDocument.description || '',
      "url": pageUrl,
      "documentation": pageUrl,
    },
    "isPartOf": {
      "@type": "APIReference",
      "name": "Applivery API Reference",
      "url": `${siteUrl}/${locale}/api/`,
    },
    "inLanguage": locale,
  };
}

// Process markdown content
let processedContent = content ? processMarkdown(content) : '';

// Resolve <ChildGrid /> placeholders from local data (no API calls)
if (processedContent.includes('data-child-grid="true"')) {
  const gridPlaceholderRegex = /<div data-child-grid="true"(?:\s+data-path="([^"]*)")?(?:\s+data-columns="(\d+)")?(?:\s+data-filters="(true|false)")?><\/div>/g;

  const docFolderPath = fullDocument.path
    ? fullDocument.path.replace(/\/[^/]+\.mdx?$/, '')
    : '';

  const placeholders: Array<{ match: string; path: string; columns: number; filters: boolean }> = [];
  let m;
  while ((m = gridPlaceholderRegex.exec(processedContent)) !== null) {
    const customPath = m[1] || '';
    const columns = parseInt(m[2] || '3', 10) as 2 | 3 | 4;
    const filters = m[3] !== 'false';
    const resolvedFolder = customPath
      ? `content/${locale}/docs/${customPath}`
      : docFolderPath;
    placeholders.push({ match: m[0], path: resolvedFolder, columns, filters });
  }

  if (placeholders.length > 0) {
    // Filter from local store — no API call
    const collectionDocs = allDocs.filter(d =>
      d.data.collection === (fullDocument.collection || 'docs') &&
      d.data.visible !== false &&
      d.data.locale === locale
    );

    for (const ph of placeholders) {
      const gridDocs = collectionDocs.filter((other) => {
        const d = other.data;
        if (!d.path || (entryId && other.id === entryId)) return false;
        if (d.type === 'archive') return false;
        if (isIndexFile(d)) return false;
        const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
        return docFolder === ph.path;
      }).sort((a, b) => {
        const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
        const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
        return orderA - orderB;
      });

      if (gridDocs.length > 0) {
        const colClass = `cols-${ph.columns}`;
        const cards = gridDocs.map((d) => {
          const href = getDocUrl({ ...d.data, id: d.id }, locale);
          const desc = d.data.description ? `<p class="child-grid-card-desc">${d.data.description}</p>` : '';
          return `<a href="${href}" class="child-grid-card">
            <span class="child-grid-card-title">${d.data.title}</span>
            ${desc}
          </a>`;
        }).join('');

        const gridHtml = `<div class="child-grid ${colClass}">${cards}</div>`;
        processedContent = processedContent.replace(ph.match, gridHtml);
      } else {
        processedContent = processedContent.replace(ph.match, '');
      }
    }
  }
}

// Extract headings for TOC
// For API pages, extract from processed HTML (since API components generate headings)
// For regular pages, extract from raw markdown
let headings: Array<{ depth: number; slug: string; text: string }> = [];
if (isApiPage && processedContent) {
  // Parse headings from rendered HTML: <h2 id="...">...</h2>
  const htmlHeadingRegex = /<h([23])\s+id="([^"]*)"[^>]*>(.*?)<\/h[23]>/gi;
  let hm;
  while ((hm = htmlHeadingRegex.exec(processedContent)) !== null) {
    const text = hm[3].replace(/<[^>]+>/g, '').trim();
    if (text) {
      headings.push({ depth: parseInt(hm[1]), slug: hm[2], text });
    }
  }
  // If no id-based headings, fall back to section titles from API components
  if (headings.length === 0) {
    const sectionTitleRegex = /<h([23])[^>]*>(.*?)<\/h[23]>/gi;
    while ((hm = sectionTitleRegex.exec(processedContent)) !== null) {
      const text = hm[2].replace(/<[^>]+>/g, '').trim();
      const slug = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
      if (text) {
        headings.push({ depth: parseInt(hm[1]), slug, text });
      }
    }
  }
} else {
  headings = content ? extractHeadings(content) : [];
}
---

<DocLayout
  title={fullDocument.title}
  breadcrumbTitle={(fullDocument.item_name && fullDocument.item_name !== 'null') ? fullDocument.item_name : (section || fullDocument.title)}
  icon={fullDocument.icon}
  sidebarIcon={fullDocument.sidebar_icon}
  description={fullDocument.description}
  ogTitle={fullDocument.og_title || fullDocument.seo_title}
  ogDescription={fullDocument.og_description || fullDocument.description}
  ogImage={resolveMediaUrl(fullDocument.og_image || fullDocument.hero_image)}
  canonical={fullDocument.canonical}
  noindex={fullDocument.noindex}
  collection={fullDocument.collection}
  section={section}
  category={category}
  readingTime={isIndex ? undefined : fullDocument.reading_time}
  tldr={fullDocument.tldr}
  keyTakeaways={fullDocument.key_takeaways}
  author={fullDocument.author}
  authorUrl={fullDocument.author_url}
  datePublished={(fullDocument.pub_date || fullDocument.date)?.toISOString()}
  dateModified={fullDocument.updated_date?.toISOString()}
  heroImage={resolveMediaUrl(fullDocument.hero_image)}
  imageAlt={fullDocument.image_alt}
  headings={headings}
  currentPath={Astro.url.pathname}
  locale={locale}
  availableTranslations={availableTranslations}
  translationSlugs={translationSlugs}
>
  {/* API Reference JSON-LD for SEO / LLM indexing */}
  {apiJsonLd && (
    <script type="application/ld+json" set:html={JSON.stringify(apiJsonLd)} />
  )}

  {/* Render document content */}
  {processedContent ? (
    <Fragment set:html={processedContent} />
  ) : !isIndex && (
    <p class="text-[var(--color-text-muted)]">No content available</p>
  )}

  {/* For API archive pages, render sub-folder cards + endpoint cards */}
  {isIndex && isApiPage && showChildGrid && (childFolders.length > 0 || childDocuments.length > 0) && (
    <div class="api-endpoint-grid">
      {/* Sub-folder cards first */}
      {childFolders.map(folder => (
        <a href={folder.href} class="api-folder-card">
          <div class="api-folder-card-header">
            <svg class="api-folder-icon" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
              <path opacity="0.5" d="M2 6.5C2 4.37868 2 3.31802 2.65901 2.65901C3.31802 2 4.37868 2 6.5 2C8.62132 2 9.68198 2 10.341 2.65901C11 3.31802 11 4.37868 11 6.5V8H6.5C4.37868 8 3.31802 8 2.65901 8.65901C2.29289 9.02513 2.12602 9.50062 2.05654 10.2H2V6.5Z" />
              <path d="M2 14C2 11.1716 2 9.75736 2.87868 8.87868C3.75736 8 5.17157 8 8 8H13H16C18.8284 8 20.2426 8 21.1213 8.87868C22 9.75736 22 11.1716 22 14V16C22 18.8284 22 20.2426 21.1213 21.1213C20.2426 22 18.8284 22 16 22H8C5.17157 22 3.75736 22 2.87868 21.1213C2 20.2426 2 18.8284 2 16V14Z" />
            </svg>
            <span class="api-folder-card-title">{folder.title}</span>
          </div>
          <p class="api-folder-card-count">{folder.endpointCount} endpoint{folder.endpointCount !== 1 ? 's' : ''}</p>
        </a>
      ))}
      {/* Endpoint cards */}
      {childDocuments.map(d => {
        const href = getDocUrl({ ...d.data, id: d.id }, locale);
        const headline = d.data.headline || '';
        // headline is "GET /path/here" — extract method
        const headlineParts = headline.match(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+(.+)$/i);
        const method = headlineParts ? headlineParts[1].toUpperCase() : '';
        // Build clean description (strip "METHOD /path — " prefix from description)
        const rawDesc = d.data.description || '';
        const cleanDesc = rawDesc.replace(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+\S+\s*[—–-]\s*/i, '');
        return (
          <a href={href} class="api-endpoint-card">
            <div class="api-endpoint-card-header">
              {method && <span class={`api-method-badge method-${method.toLowerCase()}`}>{method}</span>}
              <span class="api-endpoint-card-title">{d.data.title}</span>
            </div>
            {cleanDesc && <p class="api-endpoint-card-desc">{cleanDesc}</p>}
          </a>
        );
      })}
    </div>
  )}

  {/* For non-API index/archive pages, show standard card grid */}
  {isIndex && !isApiPage && showChildGrid && childDocuments.length > 0 && (
    <ArchiveGrid
      items={childDocuments.map(d => {
        return ({
          id: d.id,
          title: d.data.title,
          description: d.data.description,
          og_title: d.data.og_title,
          og_description: d.data.og_description,
          href: getDocUrl({ ...d.data, id: d.id }, locale),
          section: d.data.section,
          platform: d.data.platform,
          hero_image: resolveMediaUrl(d.data.hero_image),
          og_image: resolveMediaUrl(d.data.og_image),
          image_alt: d.data.image_alt,
          reading_time: d.data.reading_time,
          featured: d.data.featured,
          pub_date: d.data.pub_date?.toISOString(),
        });
      })}
      pageTitle={fullDocument.title}
      pageDescription={fullDocument.description}
      pageUrl={Astro.url.href}
      enableFilters={true}
      columns={3}
      showImages={true}
    />
  )}

  {/* Empty state for index with no children and no content */}
  {isIndex && childDocuments.length === 0 && childFolders.length === 0 && !processedContent && (
    <div class="archive-empty">
      <p class="text-[var(--color-text-muted)]">No articles in this section yet.</p>
    </div>
  )}
</DocLayout>

<style>
  :global(.archive-grid) {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .archive-empty {
    margin-top: 2rem;
    text-align: center;
    padding: 2rem;
  }

  /* API Folder Cards */
  .api-folder-card {
    display: block;
    padding: 1rem 1.125rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    text-decoration: none;
    color: inherit;
    background: var(--color-bg-subtle, var(--color-bg-secondary, rgba(0,0,0,0.02)));
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
  }

  .api-folder-card:hover {
    border-color: var(--color-primary);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    text-decoration: none;
  }

  .api-folder-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .api-folder-icon {
    width: 1.125rem;
    height: 1.125rem;
    color: var(--color-primary, #3b82f6);
    flex-shrink: 0;
  }

  .api-folder-card-title {
    font-weight: 600;
    font-size: 0.9375rem;
    color: var(--color-text-primary);
  }

  .api-folder-card-count {
    margin: 0.25rem 0 0 1.625rem;
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    line-height: 1.4;
  }

  /* API Endpoint Card Grid */
  .api-endpoint-grid {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1.5rem;
  }

  .api-endpoint-card {
    display: block;
    padding: 0.875rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    text-decoration: none;
    color: inherit;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
  }

  .api-endpoint-card:hover {
    border-color: var(--color-primary);
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
    text-decoration: none;
  }

  .api-endpoint-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .api-endpoint-card-title {
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--color-text-primary);
  }

  .api-endpoint-card-desc {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    margin: 0;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
