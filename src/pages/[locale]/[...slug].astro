---
/**
 * Dynamic documentation page route with locale support
 * URL: docs.applivery.com/{locale}/{product}/{path}
 *
 * Phase 0 rewrite: Uses getCollection('docs') from Content Layer.
 * Zero network calls during rendering — all data is local.
 */

import { getCollection } from 'astro:content';
import DocLayout from '../../layouts/DocLayout.astro';
import ArchiveGrid from '../../components/ArchiveGrid.astro';
import { resolveMediaUrl } from '../../lib/cms';
import { processMarkdown } from '../../lib/markdown';
import {
  locales,
  defaultLocale,
  isValidLocale,
  type Locale
} from '../../lib/i18n';
import {
  getIndexFolderPath,
  isIndexFile,
  extractSlugFromPath,
  extractLocaleFromPath,
  getPathPattern,
  getDocSlug,
  getDocUrl,
  extractHeadings,
  isValidSlug,
} from '../../lib/doc-helpers';

// ─── getStaticPaths — single data load, zero per-page API calls ──────

export async function getStaticPaths() {
  // ONE call to the local data store (populated by the CMS loader)
  const allDocs = await getCollection('docs');

  // Precompute translation lookup (group by translation_key)
  const translationMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const key = entry.data.translation_key;
    if (key) {
      if (!translationMap.has(key)) translationMap.set(key, []);
      translationMap.get(key)!.push(entry);
    }
  }

  // Precompute path pattern lookup for translation fallback
  const pathPatternMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const pattern = getPathPattern(entry.data);
    if (pattern) {
      if (!pathPatternMap.has(pattern)) pathPatternMap.set(pattern, []);
      pathPatternMap.get(pattern)!.push(entry);
    }
  }

  const paths: Array<{
    params: { locale: string; slug: string };
    props: {
      entry: typeof allDocs[0];
      isIndex: boolean;
      locale: Locale;
      allDocs: typeof allDocs;
      translationMap: typeof translationMap;
      pathPatternMap: typeof pathPatternMap;
    };
  }> = [];

  const validDocs = allDocs.filter((entry) => {
    return isValidSlug(entry.data.slug) || isValidSlug(entry.data.path);
  });

  for (const entry of validDocs) {
    const doc = entry.data;
    const isIndex = isIndexFile(doc);

    const docLocale: Locale = (doc.locale && locales.includes(doc.locale as Locale))
      ? (doc.locale as Locale)
      : extractLocaleFromPath(doc.path || '') || 'en';

    let fullSlug: string;

    if (isValidSlug(doc.path)) {
      fullSlug = extractSlugFromPath(doc.path, isIndex);
    } else if (isValidSlug(doc.slug)) {
      fullSlug = doc.slug;
    } else {
      const collection = doc.collection || 'docs';
      fullSlug = `${collection}/${entry.id}`;
    }

    fullSlug = fullSlug.replace(/\/+/g, '/').replace(/^\/|\/$/g, '');

    if (!fullSlug || !fullSlug.includes('/')) {
      continue;
    }

    paths.push({
      params: { locale: docLocale, slug: fullSlug },
      props: {
        entry,
        isIndex,
        locale: docLocale,
        allDocs,
        translationMap,
        pathPatternMap,
      },
    });
  }

  if (paths.length > 0 && import.meta.env.DEV) {
    console.log(`[locale]/[...slug] Generated ${paths.length} paths. Sample:`, paths.slice(0, 3).map(p => `/${p.params.locale}/${p.params.slug}`));
  }

  return paths;
}

// ─── Page rendering — all data from props, zero API calls ────────────

const { entry, isIndex, locale, allDocs, translationMap, pathPatternMap } = Astro.props;
const fullDocument = entry.data;

if (!isValidLocale(locale)) {
  return Astro.redirect(`/${defaultLocale}/`, 301);
}

// Content is already in the data store — no API call needed
const content = fullDocument.content || entry.rendered?.html || '';

// For index/archive pages, find child documents from the local store
// The show_child_grid flag (default true) controls whether the grid renders
const showChildGrid = fullDocument.show_child_grid !== false;
let childDocuments: typeof allDocs = [];
if (isIndex && showChildGrid) {
  const folderPath = getIndexFolderPath(fullDocument);
  childDocuments = allDocs.filter((other) => {
    const d = other.data;
    if (!d.path || other.id === entry.id) return false;
    if (d.visible === false) return false;
    if (d.locale !== locale) return false;
    if (isIndexFile(d)) return false;
    const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
    return docFolder === folderPath;
  }).sort((a, b) => {
    const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
    const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
    return orderA - orderB;
  });
}

// Find available translations — from precomputed maps, zero API calls
let availableTranslations: Locale[] = [locale];
const translationSlugs: Partial<Record<Locale, string>> = {};

// 1. Check translation_key
if (fullDocument.translation_key) {
  const translations = translationMap.get(fullDocument.translation_key) || [];
  for (const t of translations) {
    const tLocale = t.data.locale as Locale;
    if (tLocale !== locale && locales.includes(tLocale) && !availableTranslations.includes(tLocale)) {
      availableTranslations.push(tLocale);
      translationSlugs[tLocale] = getDocSlug({ ...t.data, id: t.id });
    }
  }
}

// 2. Fallback: check path pattern match
if (availableTranslations.length <= 1) {
  const currentPattern = getPathPattern(fullDocument);
  if (currentPattern) {
    const matches = pathPatternMap.get(currentPattern) || [];
    for (const m of matches) {
      const mLocale = m.data.locale as Locale;
      if (mLocale !== locale && locales.includes(mLocale) && !availableTranslations.includes(mLocale)) {
        availableTranslations.push(mLocale);
        translationSlugs[mLocale] = getDocSlug({ ...m.data, id: m.id });
      }
    }
  }
}

// Extract headings for TOC
const headings = content ? extractHeadings(content) : [];

// Extract section and category
const section = Array.isArray(fullDocument.section) ? fullDocument.section[0] : fullDocument.section;
const category = Array.isArray(fullDocument.category) ? fullDocument.category[0] : fullDocument.category;

// Process markdown content
let processedContent = content ? processMarkdown(content) : '';

// Resolve <ChildGrid /> placeholders from local data (no API calls)
if (processedContent.includes('data-child-grid="true"')) {
  const gridPlaceholderRegex = /<div data-child-grid="true"(?:\s+data-path="([^"]*)")?(?:\s+data-columns="(\d+)")?(?:\s+data-filters="(true|false)")?><\/div>/g;

  const docFolderPath = fullDocument.path
    ? fullDocument.path.replace(/\/[^/]+\.mdx?$/, '')
    : '';

  const placeholders: Array<{ match: string; path: string; columns: number; filters: boolean }> = [];
  let m;
  while ((m = gridPlaceholderRegex.exec(processedContent)) !== null) {
    const customPath = m[1] || '';
    const columns = parseInt(m[2] || '3', 10) as 2 | 3 | 4;
    const filters = m[3] !== 'false';
    const resolvedFolder = customPath
      ? `content/${locale}/docs/${customPath}`
      : docFolderPath;
    placeholders.push({ match: m[0], path: resolvedFolder, columns, filters });
  }

  if (placeholders.length > 0) {
    // Filter from local store — no API call
    const collectionDocs = allDocs.filter(d =>
      d.data.collection === (fullDocument.collection || 'docs') &&
      d.data.visible !== false &&
      d.data.locale === locale
    );

    for (const ph of placeholders) {
      const gridDocs = collectionDocs.filter((other) => {
        const d = other.data;
        if (!d.path || other.id === entry.id) return false;
        if (d.type === 'archive') return false;
        if (isIndexFile(d)) return false;
        const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
        return docFolder === ph.path;
      }).sort((a, b) => {
        const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
        const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
        return orderA - orderB;
      });

      if (gridDocs.length > 0) {
        const colClass = `cols-${ph.columns}`;
        const cards = gridDocs.map((d) => {
          const href = getDocUrl({ ...d.data, id: d.id }, locale);
          const desc = d.data.description ? `<p class="child-grid-card-desc">${d.data.description}</p>` : '';
          return `<a href="${href}" class="child-grid-card">
            <span class="child-grid-card-title">${d.data.title}</span>
            ${desc}
          </a>`;
        }).join('');

        const gridHtml = `<div class="child-grid ${colClass}">${cards}</div>`;
        processedContent = processedContent.replace(ph.match, gridHtml);
      } else {
        processedContent = processedContent.replace(ph.match, '');
      }
    }
  }
}
---

<DocLayout
  title={fullDocument.title}
  breadcrumbTitle={(fullDocument.item_name && fullDocument.item_name !== 'null') ? fullDocument.item_name : fullDocument.title}
  description={fullDocument.description}
  ogTitle={fullDocument.og_title || fullDocument.seo_title}
  ogDescription={fullDocument.og_description || fullDocument.description}
  ogImage={resolveMediaUrl(fullDocument.og_image || fullDocument.hero_image)}
  canonical={fullDocument.canonical}
  noindex={fullDocument.noindex}
  collection={fullDocument.collection}
  section={section}
  category={category}
  readingTime={isIndex ? undefined : fullDocument.reading_time}
  tldr={fullDocument.tldr}
  keyTakeaways={fullDocument.key_takeaways}
  author={fullDocument.author}
  authorUrl={fullDocument.author_url}
  datePublished={fullDocument.pub_date || fullDocument.date}
  dateModified={fullDocument.updated_date}
  heroImage={resolveMediaUrl(fullDocument.hero_image)}
  imageAlt={fullDocument.image_alt}
  headings={headings}
  currentPath={Astro.url.pathname}
  locale={locale}
  availableTranslations={availableTranslations}
  translationSlugs={translationSlugs}
>
  {/* Render document content */}
  {processedContent ? (
    <Fragment set:html={processedContent} />
  ) : !isIndex && (
    <p class="text-[var(--color-text-muted)]">No content available</p>
  )}

  {/* For index/archive pages, show child documents in grid (controlled by show_child_grid flag) */}
  {isIndex && showChildGrid && childDocuments.length > 0 && (
    <ArchiveGrid
      items={childDocuments.map(d => ({
        id: d.id,
        title: d.data.title,
        description: d.data.description,
        href: getDocUrl({ ...d.data, id: d.id }, locale),
        category: d.data.category,
        difficulty: d.data.difficulty,
        audience: d.data.audience,
        platform: d.data.platform,
        hero_image: resolveMediaUrl(d.data.hero_image),
        image_alt: d.data.image_alt,
        reading_time: d.data.reading_time,
        featured: d.data.featured,
        pub_date: d.data.pub_date,
      }))}
      pageTitle={fullDocument.title}
      pageDescription={fullDocument.description}
      pageUrl={Astro.url.href}
      enableFilters={true}
      columns={3}
    />
  )}

  {/* Empty state for index with no children and no content */}
  {isIndex && childDocuments.length === 0 && !processedContent && (
    <div class="archive-empty">
      <p class="text-[var(--color-text-muted)]">No articles in this section yet.</p>
    </div>
  )}
</DocLayout>

<style>
  :global(.archive-grid) {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .archive-empty {
    margin-top: 2rem;
    text-align: center;
    padding: 2rem;
  }
</style>
