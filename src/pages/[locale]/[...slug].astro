---
/**
 * Dynamic documentation page route with locale support
 * URL: docs.applivery.com/{locale}/{product}/{path}
 *
 * Phase 0 rewrite: Uses getCollection('docs') from Content Layer.
 * Zero network calls during rendering — all data is local.
 */

import { getCollection } from 'astro:content';
import DocLayout from '../../layouts/DocLayout.astro';
import ArchiveGrid from '../../components/ArchiveGrid.astro';
import { resolveMediaUrl } from '../../lib/cms';
import { processMarkdown } from '../../lib/markdown';
import {
  locales,
  defaultLocale,
  isValidLocale,
  type Locale
} from '../../lib/i18n';
import {
  getIndexFolderPath,
  isIndexFile,
  extractSlugFromPath,
  extractLocaleFromPath,
  getPathPattern,
  getDocSlug,
  getDocUrl,
  extractHeadings,
  isValidSlug,
} from '../../lib/doc-helpers';

// ─── getStaticPaths — single data load, zero per-page API calls ──────

type DocEntry = (Awaited<ReturnType<typeof getCollection>>)[0];
type DocData = DocEntry['data'];

export async function getStaticPaths() {
  // ONE call to the local data store (populated by the CMS loader)
  const allDocs = await getCollection('docs');

  // Precompute translation lookup (group by translation_key)
  const translationMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const key = entry.data.translation_key;
    if (key) {
      if (!translationMap.has(key)) translationMap.set(key, []);
      translationMap.get(key)!.push(entry);
    }
  }

  // Precompute path pattern lookup for translation fallback
  const pathPatternMap = new Map<string, typeof allDocs>();
  for (const entry of allDocs) {
    const pattern = getPathPattern(entry.data);
    if (pattern) {
      if (!pathPatternMap.has(pattern)) pathPatternMap.set(pattern, []);
      pathPatternMap.get(pattern)!.push(entry);
    }
  }

  const paths: Array<{
    params: { locale: string; slug: string };
    props: {
      entry: DocEntry | null;
      isIndex: boolean;
      locale: Locale;
      allDocs: typeof allDocs;
      translationMap: typeof translationMap;
      pathPatternMap: typeof pathPatternMap;
      virtual?: { title: string; path: string; collection: string };
    };
  }> = [];

  const resolveDocLocale = (doc: { locale?: string; path?: string }): Locale =>
    (doc.locale && locales.includes(doc.locale as Locale))
      ? (doc.locale as Locale)
      : extractLocaleFromPath(doc.path || '') || 'en';

  const validDocs = allDocs.filter((entry) => {
    const doc = entry.data;
    if (!isValidSlug(doc.slug) && !isValidSlug(doc.path)) return false;
    if (doc.type !== 'archive') return true;

    const folderPath = getIndexFolderPath(doc);
    if (!folderPath) return false;
    const docLocale = resolveDocLocale(doc);

    const hasChildren = allDocs.some((other) => {
      const d = other.data;
      if (!d.path || other.id === entry.id) return false;
      if (d.visible === false) return false;
      if (resolveDocLocale(d) !== docLocale) return false;
      if (isIndexFile(d)) return false;
      const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
      return docFolder === folderPath;
    });

    return hasChildren;
  });

  for (const entry of validDocs) {
    const doc = entry.data;
    const isIndex = isIndexFile(doc);

    const docLocale: Locale = resolveDocLocale(doc);

    let fullSlug: string;

    if (isValidSlug(doc.path)) {
      fullSlug = extractSlugFromPath(doc.path, isIndex);
    } else if (isValidSlug(doc.slug)) {
      fullSlug = doc.slug;
    } else {
      const collection = doc.collection || 'docs';
      fullSlug = `${collection}/${entry.id}`;
    }

    fullSlug = fullSlug.replace(/\/+/g, '/').replace(/^\/|\/$/g, '');

    if (!fullSlug || !fullSlug.includes('/')) {
      continue;
    }

    paths.push({
      params: { locale: docLocale, slug: fullSlug },
      props: {
        entry,
        isIndex,
        locale: docLocale,
        allDocs,
        translationMap,
        pathPatternMap,
      },
    });
  }

  const indexFoldersByLocale = new Map<Locale, Set<string>>();
  const childFoldersByLocale = new Map<Locale, Set<string>>();
  const pathKeys = new Set(paths.map(p => `${p.params.locale}:${p.params.slug}`));

  for (const entry of allDocs) {
    const doc = entry.data;
    if (!doc.path) continue;
    const docLocale = resolveDocLocale(doc);
    if (isIndexFile(doc)) {
      const folderPath = getIndexFolderPath(doc);
      if (!folderPath) continue;
      if (!indexFoldersByLocale.has(docLocale)) indexFoldersByLocale.set(docLocale, new Set());
      indexFoldersByLocale.get(docLocale)!.add(folderPath);
      continue;
    }
    if (doc.visible === false) continue;
    const docFolder = doc.path.replace(/\/[^/]+\.mdx?$/, '');
    if (!childFoldersByLocale.has(docLocale)) childFoldersByLocale.set(docLocale, new Set());
    childFoldersByLocale.get(docLocale)!.add(docFolder);
  }

  const toTitle = (value: string) =>
    value
      .split('-')
      .map(part => (part ? part[0].toUpperCase() + part.slice(1) : part))
      .join(' ');

  for (const [docLocale, folderPaths] of childFoldersByLocale.entries()) {
    const indexFolders = indexFoldersByLocale.get(docLocale) || new Set<string>();
    for (const folderPath of folderPaths) {
      if (indexFolders.has(folderPath)) continue;
      const folderSlug = extractSlugFromPath(`${folderPath}/index.md`, true);
      if (!folderSlug || !folderSlug.includes('/')) continue;
      const key = `${docLocale}:${folderSlug}`;
      if (pathKeys.has(key)) continue;
      const segment = folderSlug.split('/').pop() || folderSlug;
      const title = toTitle(segment);
      const collection = folderSlug.split('/')[0] || 'docs';
      paths.push({
        params: { locale: docLocale, slug: folderSlug },
        props: {
          entry: null,
          isIndex: true,
          locale: docLocale,
          allDocs,
          translationMap,
          pathPatternMap,
          virtual: { title, path: folderPath, collection },
        },
      });
      pathKeys.add(key);
    }
  }

  if (paths.length > 0 && import.meta.env.DEV) {
    console.log(`[locale]/[...slug] Generated ${paths.length} paths. Sample:`, paths.slice(0, 3).map(p => `/${p.params.locale}/${p.params.slug}`));
  }

  return paths;
}

// ─── Page rendering — all data from props, zero API calls ────────────

const { entry, isIndex, locale, allDocs, translationMap, pathPatternMap, virtual } = Astro.props;
const fullDocument: DocData = entry?.data || {
  title: virtual?.title || 'Untitled',
  description: undefined,
  content: '',
  collection: virtual?.collection || 'docs',
  locale,
  type: 'archive',
  path: virtual?.path,
  slug: undefined,
  visible: true,
  item_name: virtual?.title,
  show_child_grid: true,
};

if (!isValidLocale(locale)) {
  return Astro.redirect(`/${defaultLocale}/`, 301);
}

// Content is already in the data store — no API call needed
const content = fullDocument.content || entry?.rendered?.html || '';

// For index/archive pages, find child documents from the local store
// The show_child_grid flag (default true) controls whether the grid renders
const showChildGrid = fullDocument.show_child_grid !== false;
let childDocuments: typeof allDocs = [];
const entryId = entry?.id;
if (isIndex && showChildGrid) {
  const folderPath = getIndexFolderPath(fullDocument);
  childDocuments = allDocs.filter((other) => {
    const d = other.data;
    if (!d.path || (entryId && other.id === entryId)) return false;
    if (d.visible === false) return false;
    if (d.locale !== locale) return false;
    if (isIndexFile(d)) return false;
    const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
    return docFolder === folderPath;
  }).sort((a, b) => {
    const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
    const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
    return orderA - orderB;
  });
}

const normalizeString = (value?: string | null) => {
  if (!value) return '';
  const trimmed = value.trim();
  if (!trimmed || trimmed.toLowerCase() === 'null' || trimmed.toLowerCase() === 'undefined') return '';
  return trimmed;
};

const getMenuLabel = (doc: DocData) => {
  if (doc.item_name && doc.item_name !== 'null') return doc.item_name;
  return doc.title;
};

// Find available translations — from precomputed maps, zero API calls
let availableTranslations: Locale[] = [locale];
const translationSlugs: Partial<Record<Locale, string>> = {};

// 1. Check translation_key
if (fullDocument.translation_key) {
  const translations = translationMap.get(fullDocument.translation_key) || [];
  for (const t of translations) {
    const tLocale = t.data.locale as Locale;
    if (tLocale !== locale && locales.includes(tLocale) && !availableTranslations.includes(tLocale)) {
      availableTranslations.push(tLocale);
      translationSlugs[tLocale] = getDocSlug({ ...t.data, id: t.id });
    }
  }
}

// 2. Fallback: check path pattern match
if (availableTranslations.length <= 1) {
  const currentPattern = getPathPattern(fullDocument);
  if (currentPattern) {
    const matches = pathPatternMap.get(currentPattern) || [];
    for (const m of matches) {
      const mLocale = m.data.locale as Locale;
      if (mLocale !== locale && locales.includes(mLocale) && !availableTranslations.includes(mLocale)) {
        availableTranslations.push(mLocale);
        translationSlugs[mLocale] = getDocSlug({ ...m.data, id: m.id });
      }
    }
  }
}

// Extract headings for TOC
const headings = content ? extractHeadings(content) : [];

// Extract section and category
const section = Array.isArray(fullDocument.section) ? fullDocument.section[0] : fullDocument.section;
const category = Array.isArray(fullDocument.category) ? fullDocument.category[0] : fullDocument.category;

// Process markdown content
let processedContent = content ? processMarkdown(content) : '';

// Resolve <ChildGrid /> placeholders from local data (no API calls)
if (processedContent.includes('data-child-grid="true"')) {
  const gridPlaceholderRegex = /<div data-child-grid="true"(?:\s+data-path="([^"]*)")?(?:\s+data-columns="(\d+)")?(?:\s+data-filters="(true|false)")?><\/div>/g;

  const docFolderPath = fullDocument.path
    ? fullDocument.path.replace(/\/[^/]+\.mdx?$/, '')
    : '';

  const placeholders: Array<{ match: string; path: string; columns: number; filters: boolean }> = [];
  let m;
  while ((m = gridPlaceholderRegex.exec(processedContent)) !== null) {
    const customPath = m[1] || '';
    const columns = parseInt(m[2] || '3', 10) as 2 | 3 | 4;
    const filters = m[3] !== 'false';
    const resolvedFolder = customPath
      ? `content/${locale}/docs/${customPath}`
      : docFolderPath;
    placeholders.push({ match: m[0], path: resolvedFolder, columns, filters });
  }

  if (placeholders.length > 0) {
    // Filter from local store — no API call
    const collectionDocs = allDocs.filter(d =>
      d.data.collection === (fullDocument.collection || 'docs') &&
      d.data.visible !== false &&
      d.data.locale === locale
    );

    for (const ph of placeholders) {
      const gridDocs = collectionDocs.filter((other) => {
        const d = other.data;
        if (!d.path || (entryId && other.id === entryId)) return false;
        if (d.type === 'archive') return false;
        if (isIndexFile(d)) return false;
        const docFolder = d.path.replace(/\/[^/]+\.mdx?$/, '');
        return docFolder === ph.path;
      }).sort((a, b) => {
        const orderA = a.data.sidebar_position ?? a.data.order_num ?? a.data.weight ?? 999;
        const orderB = b.data.sidebar_position ?? b.data.order_num ?? b.data.weight ?? 999;
        return orderA - orderB;
      });

      if (gridDocs.length > 0) {
        const colClass = `cols-${ph.columns}`;
        const cards = gridDocs.map((d) => {
          const href = getDocUrl({ ...d.data, id: d.id }, locale);
          const desc = d.data.description ? `<p class="child-grid-card-desc">${d.data.description}</p>` : '';
          return `<a href="${href}" class="child-grid-card">
            <span class="child-grid-card-title">${d.data.title}</span>
            ${desc}
          </a>`;
        }).join('');

        const gridHtml = `<div class="child-grid ${colClass}">${cards}</div>`;
        processedContent = processedContent.replace(ph.match, gridHtml);
      } else {
        processedContent = processedContent.replace(ph.match, '');
      }
    }
  }
}
---

<DocLayout
  title={fullDocument.title}
  breadcrumbTitle={(fullDocument.item_name && fullDocument.item_name !== 'null') ? fullDocument.item_name : fullDocument.title}
  description={fullDocument.description}
  ogTitle={fullDocument.og_title || fullDocument.seo_title}
  ogDescription={fullDocument.og_description || fullDocument.description}
  ogImage={resolveMediaUrl(fullDocument.og_image || fullDocument.hero_image)}
  canonical={fullDocument.canonical}
  noindex={fullDocument.noindex}
  collection={fullDocument.collection}
  section={section}
  category={category}
  readingTime={isIndex ? undefined : fullDocument.reading_time}
  tldr={fullDocument.tldr}
  keyTakeaways={fullDocument.key_takeaways}
  author={fullDocument.author}
  authorUrl={fullDocument.author_url}
  datePublished={fullDocument.pub_date || fullDocument.date}
  dateModified={fullDocument.updated_date}
  heroImage={resolveMediaUrl(fullDocument.hero_image)}
  imageAlt={fullDocument.image_alt}
  headings={headings}
  currentPath={Astro.url.pathname}
  locale={locale}
  availableTranslations={availableTranslations}
  translationSlugs={translationSlugs}
>
  {/* Render document content */}
  {processedContent ? (
    <Fragment set:html={processedContent} />
  ) : !isIndex && (
    <p class="text-[var(--color-text-muted)]">No content available</p>
  )}

  {/* For index/archive pages, show child documents in grid (controlled by show_child_grid flag) */}
  {isIndex && showChildGrid && childDocuments.length > 0 && (
    <ArchiveGrid
      items={childDocuments.map(d => {
        return ({
          id: d.id,
          title: d.data.title,
          description: d.data.description,
          og_title: d.data.og_title,
          og_description: d.data.og_description,
          href: getDocUrl({ ...d.data, id: d.id }, locale),
          section: d.data.section,
          platform: d.data.platform,
          hero_image: resolveMediaUrl(d.data.hero_image),
          og_image: resolveMediaUrl(d.data.og_image),
          image_alt: d.data.image_alt,
          reading_time: d.data.reading_time,
          featured: d.data.featured,
          pub_date: d.data.pub_date,
        });
      })}
      pageTitle={fullDocument.title}
      pageDescription={fullDocument.description}
      pageUrl={Astro.url.href}
      enableFilters={true}
      columns={3}
      showImages={true}
    />
  )}

  {/* Empty state for index with no children and no content */}
  {isIndex && childDocuments.length === 0 && !processedContent && (
    <div class="archive-empty">
      <p class="text-[var(--color-text-muted)]">No articles in this section yet.</p>
    </div>
  )}
</DocLayout>

<style>
  :global(.archive-grid) {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .archive-empty {
    margin-top: 2rem;
    text-align: center;
    padding: 2rem;
  }
</style>
