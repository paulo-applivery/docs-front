---
/**
 * SSR API documentation page
 *
 * This page is server-side rendered (NOT static) so that API doc changes
 * from the CMS are visible immediately without a full rebuild.
 *
 * Cloudflare CDN caches the response (Cache-Control headers) so 99% of
 * visitors get ~20ms TTFB. Cache is purged by the CMS after each import.
 */
export const prerender = false

import DocLayout from '../../../layouts/DocLayout.astro'
import { resolveMediaUrl, getAllSettings, type Document } from '../../../lib/cms'
import { processMarkdown } from '../../../lib/markdown'
import {
  locales,
  isValidLocale,
  defaultLocale,
  type Locale,
} from '../../../lib/i18n'
import {
  isIndexFile,
  extractSlugFromPath,
  getDocUrl,
  extractHeadings,
} from '../../../lib/doc-helpers'

const { locale, slug } = Astro.params

// Validate locale
if (!locale || !isValidLocale(locale)) {
  return Astro.redirect(`/${defaultLocale}/api/${slug || ''}`, 301)
}

const cmsUrl = import.meta.env.CMS_URL || 'http://localhost:3000'
const apiKey = import.meta.env.CMS_API_KEY || ''

const headers: Record<string, string> = {
  'Content-Type': 'application/json',
}
if (apiKey) {
  headers['Authorization'] = `Bearer ${apiKey}`
  headers['x-api-key'] = apiKey
}

// Fetch the single document and navigation in parallel
const docSlug = slug ? `api/${slug}` : 'api'
let doc: any = null
let nav: any = null
let settings: any = null
let fetchError: string | null = null

try {
  const [docRes, navRes, settingsData] = await Promise.all([
    fetch(`${cmsUrl}/api/documents/api-doc-by-slug?slug=${encodeURIComponent(docSlug)}&locale=${locale}`, {
      headers,
      // @ts-ignore — Cloudflare Workers cf property
      cf: { cacheTtl: 60, cacheEverything: true },
    }),
    fetch(`${cmsUrl}/api/documents/api-navigation?locale=${locale}&slim=1`, {
      headers,
      // @ts-ignore — Cloudflare Workers cf property
      cf: { cacheTtl: 300, cacheEverything: true },
    }),
    getAllSettings(),
  ])

  if (docRes.ok) {
    const docData = await docRes.json()
    doc = docData.document
  } else if (docRes.status === 404) {
    // Let it fall through to 404 handling below
  } else {
    fetchError = `CMS returned ${docRes.status}`
  }

  if (navRes.ok) {
    nav = await navRes.json()
  }

  settings = settingsData
} catch (err: any) {
  fetchError = err.message || 'Failed to fetch from CMS'
  console.error('[SSR API] Fetch error:', err)
}

// 404 handling
if (!doc && !fetchError) {
  Astro.response.status = 404
}

// Set cache headers for Cloudflare CDN
Astro.response.headers.set('Cache-Control', 'public, max-age=60, stale-while-revalidate=300')

// Build documents array for the sidebar from navigation data
// IMPORTANT: paths MUST keep the "api/" prefix so the Sidebar generates
// correct hrefs like /en/api/android instead of /en/android
const sidebarDocuments: Document[] = []

function flattenNavToDocuments(items: any[]) {
  if (!items) return
  for (const item of items) {
    // item.slug already includes the api/ prefix (e.g. "api/android", "api/android/get-devices")
    const itemSlug = item.slug || ''

    if (item.type === 'folder') {
      sidebarDocuments.push({
        id: item.id,
        title: item.title,
        description: '',
        content: '',
        collection: 'api',
        locale: locale as string,
        type: 'archive',
        path: `content/${locale}/docs/${itemSlug}/index.md`,
        slug: itemSlug,
        visible: true,
        sidebar_position: item.order,
        item_name: item.title,
        sidebar_icon: item.icon,
        icon: item.icon,
      } as Document)

      if (item.children) {
        flattenNavToDocuments(item.children)
      }
    } else if (item.type === 'endpoint') {
      const leafSlug = itemSlug.split('/').pop() || ''
      const parentFolder = itemSlug.split('/').slice(0, -1).join('/')
      sidebarDocuments.push({
        id: item.id,
        title: item.title,
        description: '',
        content: '',
        collection: 'api',
        locale: locale as string,
        type: 'article',
        path: `content/${locale}/docs/${parentFolder}/${leafSlug}.md`,
        slug: itemSlug,
        visible: true,
        sidebar_position: item.order,
        item_name: item.title,
        sidebar_icon: item.icon,
        icon: item.icon,
        headline: item.method ? `${item.method} ${item.apiPath || ''}` : undefined,
      } as Document)
    }
  }
}

if (nav?.navigation) {
  // Add the top-level API Reference index
  sidebarDocuments.push({
    id: 'api-index',
    title: 'API Reference',
    description: '',
    content: '',
    collection: 'api',
    locale: locale as string,
    type: 'archive',
    path: `content/${locale}/docs/api/index.md`,
    slug: 'api',
    visible: true,
    sidebar_position: 0,
    item_name: 'API Reference',
    sidebar_icon: 'code',
    icon: 'code',
  } as Document)

  flattenNavToDocuments(nav.navigation)
}

// Process content if we have a document
const fullDocument = doc || {
  title: fetchError ? 'Error Loading Page' : 'Not Found',
  description: fetchError ? 'There was an error loading this page.' : 'The requested API documentation page was not found.',
  collection: 'api',
  locale,
  type: 'article',
  visible: true,
}

const isIndex = fullDocument.type === 'archive'
const rawContent = fullDocument.content || ''

// Process markdown → HTML
let processedContent = ''
if (rawContent) {
  // If content has frontmatter, strip it before processing
  const fmRegex = /^---\n[\s\S]*?\n---\n?/
  const contentBody = rawContent.replace(fmRegex, '')
  processedContent = processMarkdown(contentBody)
}

// Extract headings for TOC
let headings: Array<{ depth: number; slug: string; text: string }> = []
if (processedContent) {
  const htmlHeadingRegex = /<h([23])\s+id="([^"]*)"[^>]*>(.*?)<\/h[23]>/gi
  let hm
  while ((hm = htmlHeadingRegex.exec(processedContent)) !== null) {
    const text = hm[3].replace(/<[^>]+>/g, '').trim()
    if (text) {
      headings.push({ depth: parseInt(hm[1]), slug: hm[2], text })
    }
  }
  if (headings.length === 0) {
    const sectionTitleRegex = /<h([23])[^>]*>(.*?)<\/h[23]>/gi
    while ((hm = sectionTitleRegex.exec(processedContent)) !== null) {
      const text = hm[2].replace(/<[^>]+>/g, '').trim()
      const slugText = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '')
      if (text) {
        headings.push({ depth: parseInt(hm[1]), slug: slugText, text })
      }
    }
  }
} else if (!isIndex) {
  headings = rawContent ? extractHeadings(rawContent.replace(/^---\n[\s\S]*?\n---\n?/, '')) : []
}

// Graceful fallback: if doc exists with API metadata but no content, show basic endpoint info
if (doc && !processedContent && !isIndex && doc._api) {
  const m = doc._api.method || ''
  const p = doc._api.path || ''
  const desc = doc.description || ''
  processedContent = `<div class="api-basic-info"><p class="api-basic-endpoint"><code>${m} ${p}</code></p>${desc ? `<p>${desc}</p>` : ''}<p class="text-sm" style="color:var(--color-text-muted);margin-top:1rem;">Full documentation content is being generated. Please check back shortly.</p></div>`
}

// Build JSON-LD for API reference pages
const siteUrl = Astro.site?.href || Astro.url.origin
const pageUrl = new URL(Astro.url.pathname, siteUrl).href
const headline = fullDocument.headline || fullDocument.title

let apiJsonLd: Record<string, any> | null = null
if (doc) {
  apiJsonLd = {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": fullDocument.title,
    "headline": headline,
    "description": fullDocument.description || '',
    "url": pageUrl,
    "datePublished": fullDocument.pub_date || fullDocument.created_at,
    "dateModified": fullDocument.updated_date || fullDocument.updated_at,
    "articleSection": "API Reference",
    "proficiencyLevel": "Advanced",
    "about": {
      "@type": "WebAPI",
      "name": headline,
      "description": fullDocument.description || '',
      "url": pageUrl,
      "documentation": pageUrl,
    },
    "isPartOf": {
      "@type": "APIReference",
      "name": "Applivery API Reference",
      "url": `${siteUrl}/${locale}/api/`,
    },
    "inLanguage": locale,
  }
}

// For archive/index pages, build child data from navigation
let childDocuments: any[] = []
let childFolders: Array<{ id: string; title: string; description: string; href: string; icon?: string; order: number; endpointCount: number }> = []

if (isIndex && nav?.navigation) {
  // Find the current folder in the navigation tree
  const currentSlug = fullDocument.slug || docSlug
  const currentFolderTag = currentSlug.replace(/^api\/?/, '')

  function findNavFolder(items: any[], targetTag: string): any[] | null {
    if (!targetTag) return items // root level
    for (const item of items) {
      const itemTag = item.slug?.replace(/^api\//, '') || ''
      if (itemTag === targetTag) return item.children || []
      if (item.children) {
        const found = findNavFolder(item.children, targetTag)
        if (found) return found
      }
    }
    return null
  }

  const children = findNavFolder(nav.navigation, currentFolderTag) || (currentFolderTag === '' ? nav.navigation : [])

  for (const child of children) {
    if (child.type === 'folder') {
      childFolders.push({
        id: child.id,
        title: child.title,
        description: `API endpoints for ${child.title}`,
        href: `/${locale}/${child.slug}`,
        icon: child.icon,
        order: child.order ?? 999,
        endpointCount: child.endpointCount || 0,
      })
    } else if (child.type === 'endpoint') {
      const method = child.method || ''
      childDocuments.push({
        id: child.id,
        data: {
          title: child.title,
          description: child.title,
          headline: child.method ? `${child.method} ${child.apiPath || ''}` : '',
          visible: true,
          sidebar_position: child.order,
        },
        href: `/${locale}/${child.slug}`,
        method,
      })
    }
  }
}

// Extract section
const section = Array.isArray(fullDocument.section) ? fullDocument.section[0] : fullDocument.section
const category = Array.isArray(fullDocument.category) ? fullDocument.category[0] : fullDocument.category
---

<DocLayout
  title={fullDocument.title}
  breadcrumbTitle={(fullDocument.item_name && fullDocument.item_name !== 'null') ? fullDocument.item_name : (section || fullDocument.title)}
  icon={fullDocument.icon}
  sidebarIcon={fullDocument.sidebar_icon}
  description={fullDocument.description}
  ogTitle={fullDocument.og_title || fullDocument.seo_title}
  ogDescription={fullDocument.og_description || fullDocument.description}
  ogImage={resolveMediaUrl(fullDocument.og_image || fullDocument.hero_image)}
  canonical={fullDocument.canonical}
  noindex={fullDocument.noindex}
  collection="api"
  section={section}
  category={category}
  headings={headings}
  currentPath={Astro.url.pathname}
  sidebarDocuments={sidebarDocuments}
  settings={settings}
  locale={locale as Locale}
>
  {/* API Reference JSON-LD for SEO / LLM indexing */}
  {apiJsonLd && (
    <script type="application/ld+json" set:html={JSON.stringify(apiJsonLd)} />
  )}

  {/* Error state */}
  {fetchError && (
    <div class="error-banner">
      <p>Unable to load this page. Please try again later.</p>
    </div>
  )}

  {/* Render document content */}
  {processedContent ? (
    <Fragment set:html={processedContent} />
  ) : !isIndex && !fetchError && doc && (
    <p class="text-[var(--color-text-muted)]">No content available</p>
  )}

  {/* For archive pages, render sub-folder cards + endpoint cards */}
  {isIndex && (childFolders.length > 0 || childDocuments.length > 0) && (
    <div class="api-endpoint-grid">
      {/* Sub-folder cards first */}
      {childFolders.map(folder => (
        <a href={folder.href} class="api-folder-card">
          <div class="api-folder-card-header">
            <svg class="api-folder-icon" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
              <path opacity="0.5" d="M2 6.5C2 4.37868 2 3.31802 2.65901 2.65901C3.31802 2 4.37868 2 6.5 2C8.62132 2 9.68198 2 10.341 2.65901C11 3.31802 11 4.37868 11 6.5V8H6.5C4.37868 8 3.31802 8 2.65901 8.65901C2.29289 9.02513 2.12602 9.50062 2.05654 10.2H2V6.5Z" />
              <path d="M2 14C2 11.1716 2 9.75736 2.87868 8.87868C3.75736 8 5.17157 8 8 8H13H16C18.8284 8 20.2426 8 21.1213 8.87868C22 9.75736 22 11.1716 22 14V16C22 18.8284 22 20.2426 21.1213 21.1213C20.2426 22 18.8284 22 16 22H8C5.17157 22 3.75736 22 2.87868 21.1213C2 20.2426 2 18.8284 2 16V14Z" />
            </svg>
            <span class="api-folder-card-title">{folder.title}</span>
          </div>
          <p class="api-folder-card-count">{folder.endpointCount} endpoint{folder.endpointCount !== 1 ? 's' : ''}</p>
        </a>
      ))}
      {/* Endpoint cards */}
      {childDocuments.map(d => {
        const headline = d.data.headline || ''
        const headlineParts = headline.match(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+(.+)$/i)
        const method = headlineParts ? headlineParts[1].toUpperCase() : (d.method || '')
        const rawDesc = d.data.description || ''
        const cleanDesc = rawDesc.replace(/^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\s+\S+\s*[—–-]\s*/i, '')
        return (
          <a href={d.href} class="api-endpoint-card">
            <div class="api-endpoint-card-header">
              {method && <span class={`api-method-badge method-${method.toLowerCase()}`}>{method}</span>}
              <span class="api-endpoint-card-title">{d.data.title}</span>
            </div>
            {cleanDesc && <p class="api-endpoint-card-desc">{cleanDesc}</p>}
          </a>
        )
      })}
    </div>
  )}

  {/* 404 state */}
  {!doc && !fetchError && (
    <div class="not-found-content">
      <h2>Page Not Found</h2>
      <p>The API documentation page you're looking for doesn't exist or has been moved.</p>
      <a href={`/${locale}/api/`} class="back-link">Back to API Reference</a>
    </div>
  )}

  {/* Empty archive state */}
  {isIndex && childDocuments.length === 0 && childFolders.length === 0 && !processedContent && !fetchError && doc && (
    <div class="archive-empty">
      <p class="text-[var(--color-text-muted)]">No endpoints in this section yet.</p>
    </div>
  )}
</DocLayout>

<style>
  .error-banner {
    padding: 1rem 1.5rem;
    background: var(--color-bg-warning, #fef3cd);
    border: 1px solid var(--color-border-warning, #ffc107);
    border-radius: 0.5rem;
    margin-bottom: 1.5rem;
    color: var(--color-text-warning, #856404);
  }

  .not-found-content {
    text-align: center;
    padding: 3rem 1rem;
  }

  .not-found-content h2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .not-found-content p {
    color: var(--color-text-muted);
    margin-bottom: 1.5rem;
  }

  .back-link {
    color: var(--color-primary);
    text-decoration: none;
    font-weight: 500;
  }

  .back-link:hover {
    text-decoration: underline;
  }

  .archive-empty {
    margin-top: 2rem;
    text-align: center;
    padding: 2rem;
  }

  /* API Folder Cards */
  .api-folder-card {
    display: block;
    padding: 1rem 1.125rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    text-decoration: none;
    color: inherit;
    background: var(--color-bg-subtle, var(--color-bg-secondary, rgba(0,0,0,0.02)));
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
  }

  .api-folder-card:hover {
    border-color: var(--color-primary);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    text-decoration: none;
  }

  .api-folder-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .api-folder-icon {
    width: 1.125rem;
    height: 1.125rem;
    color: var(--color-primary, #3b82f6);
    flex-shrink: 0;
  }

  .api-folder-card-title {
    font-weight: 600;
    font-size: 0.9375rem;
    color: var(--color-text-primary);
  }

  .api-folder-card-count {
    margin: 0.25rem 0 0 1.625rem;
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    line-height: 1.4;
  }

  /* API Endpoint Card Grid */
  .api-endpoint-grid {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1.5rem;
  }

  .api-endpoint-card {
    display: block;
    padding: 0.875rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    text-decoration: none;
    color: inherit;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
  }

  .api-endpoint-card:hover {
    border-color: var(--color-primary);
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
    text-decoration: none;
  }

  .api-endpoint-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .api-endpoint-card-title {
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--color-text-primary);
  }

  .api-endpoint-card-desc {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    margin: 0;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
